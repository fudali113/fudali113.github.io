{"meta":{"title":"fudali","subtitle":"do one`s best","description":"do one`s best APE","author":"fudali","url":"http://fudali.cc"},"pages":[{"title":"","date":"2017-03-17T08:41:11.000Z","updated":"2017-03-17T08:41:11.000Z","comments":false,"path":"categories/index.html","permalink":"http://fudali.cc/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2016-12-12T16:00:00.000Z","updated":"2017-03-17T09:39:12.000Z","comments":true,"path":"about/index.html","permalink":"http://fudali.cc/about/index.html","excerpt":"","text":"hi, i am a sunshine boy ^_^ my cool photo loading error These are my hobby: sports , basketball coding running beautiful girl fork me github"},{"title":"","date":"2017-03-17T08:40:51.000Z","updated":"2017-03-17T08:40:51.000Z","comments":false,"path":"tags/index.html","permalink":"http://fudali.cc/tags/index.html","excerpt":"","text":""},{"title":"doob doc","date":"2017-03-09T16:00:00.000Z","updated":"2017-03-17T09:39:22.000Z","comments":true,"path":"doob/index.html","permalink":"http://fudali.cc/doob/index.html","excerpt":"","text":"docget start get start 简单的使用并运行起来 使用"},{"title":"","date":"2017-03-17T16:08:53.000Z","updated":"2017-03-17T16:08:53.000Z","comments":true,"path":"note/http.html","permalink":"http://fudali.cc/note/http.html","excerpt":"","text":"Transfer-Encoding: chunked客服端将分段解析tcp发送的数据，以0结尾"},{"title":"doob doc","date":"2017-03-09T16:00:00.000Z","updated":"2017-03-18T04:58:13.000Z","comments":true,"path":"note/index.html","permalink":"http://fudali.cc/note/index.html","excerpt":"","text":"golang 中的错误"},{"title":"go错误类型","date":"2016-03-15T16:00:00.000Z","updated":"2017-03-18T08:21:51.000Z","comments":true,"path":"note/go-error.html","permalink":"http://fudali.cc/note/go-error.html","excerpt":"","text":"引包错误12use of package sort without selector该错误出现在引入报名与当前包中定义的变量或函数重名"},{"title":"doob入门","date":"2016-01-12T16:00:00.000Z","updated":"2017-03-18T08:21:46.000Z","comments":true,"path":"doob/doob-get-start.html","permalink":"http://fudali.cc/doob/doob-get-start.html","excerpt":"","text":"快速开始下载依赖1go get github.com/fudali113/doob 创建main函数文件demo.go1234567891011121314package mainimport &quot;github.com/fudali113/doob&quot;func main() &#123; doob.Start(8888)&#125;func init()&#123; router := doob.DefaultRouter() router.Get(&quot;/test&quot;, func (ctx *doob.Context) interface&#123;&#125; &#123; return &quot;test&quot; &#125;)&#125; 编译运行1go run demo.go 浏览效果打开浏览器并访问 http://localhost:8888/test"}],"posts":[{"title":"tcp和udp网络协议","slug":"tcp-and-udp-protocols","date":"2017-03-16T16:00:00.000Z","updated":"2017-03-18T04:56:12.000Z","comments":true,"path":"2017/03/17/tcp-and-udp-protocols/","link":"","permalink":"http://fudali.cc/2017/03/17/tcp-and-udp-protocols/","excerpt":"","text":"简介TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，UDP是无连接的协议。 TCP什么是TCP 是传输层的一种面向连接的协议 处理下层的不可靠数据使之变得可靠(确定通过网络发送的数据报的状态并且如果部分已被丢弃则处理信息的重发的任务并按正确的顺序重新组合成消息以提供可靠性) TCP驻留在传输层中，并仅驻留在实际处理数据报的机器上，确保数据报已从源机器到目标机器；它不驻留在简单路由数据报的设备上，因此网关中没有TCP层。 tcp协议留驻在传输层示意图 TCP的特点 单播协议:TCP基于单播网络模型，支持两方之间的数据交换。它不支持广播或多播网络模型。 连接状态:TCP使用两个端点之间的同步状态，而不是在网络内强加一个状态来支持连接。该同步状态被设置为初始连接过程的一部分，因此TCP可以被认为是面向连接的协议。许多协议设计旨在确保每个本地状态转换被传送到远程方并由其确认。 可靠性: 可靠性意味着在连接的一端传递给TCP驱动程序的八位字节流将通过网络传输，使得流作为相同的八位字节序列呈现给远程进程，顺序与生成的由发送方。这意味着协议检测数据流的分段何时已被网络丢弃，重新排序，复制或损坏。在必要的情况下，发送器将重传损坏的段，以便允许接收器重建原始数据流。这意味着TCP发送方必须保持所有发送数据的本地副本，直到它接收到接收方已经完成数据的准确传送的指示为止。 全双工: TCP是全双工协议; 它允许双方在单个TCP连接的上下文内发送和接收数据。 流: 虽然TCP使用分组结构用于网络传输，但TCP是真正的流传输协议，并且应用级网络操作不透明。一些协议明确地封装每个应用事务;对于每一次写，都必须有一个匹配的读。以这种方式，在网络上保留数据流到逻辑记录结构的应用派生分段。TCP不保留施加在数据流上的这种隐式结构，使得在网络协议内的写和读操作之间不存在配对。例如，TCP应用可以将三个数据块按顺序写入网络连接，其可以由远程读取器在单个读取操作中收集。TCP会话中使用的数据块（段）的大小在会话开始时协商。发送器尝试在接收器的最大段大小，配置的发送器的最大段大小和最大可支持的非分段分组大小的限制内使用它可以用于数据传输的最大段大小网络路径（路径最大传输单元[MTU]）。路径MTU周期性地刷新以适应在TCP连接活动时可能发生在网络内的任何改变。 速率适配: TCP也是速率自适应协议，因为数据传输速率旨在适应网络内的主要负载条件并适应接收机的处理能力。没有预定的TCP数据传输速率; 如果网络和接收器都具有额外的可用容量，则TCP发送器将尝试向网络注入更多数据以占用此可用空间。相反，如果有拥塞，TCP发送方将降低其发送速率以允许网络恢复。该适配功能试图实现最高可能的数据传输速率，而不触发一致的数据丢失。 TCP建立连接三次握手客户端发送SYN消息; 服务器发送组合对客户端的SYN的ACK并且包含服务器的SYN的消息; 然后客户端发送对服务器的SYN的ACK。 建立连接步鄹图 连接在其生命周期中经过一系列状态: 侦听，SYN发送，SYN接收，建立，FIN-WAIT-1，FIN-WAIT-2，CLOSE-等待，CLOSING，LAST-ACK，TIME-WAIT和虚构状态CLOSED。CLOSED是虚构的，因为它代表没有TCP时的状态，因此没有连接。123456789101112131415161718192021LISTEN - 表示等待来自任何远程TCP和端口的连接请求。SYN-SENT - 表示在发送连接请求之后等待匹配的连接请求。SYN-RECEIVED - 表示在接收和发送连接请求之后等待确认连接请求确认。ESTABLISHED - 表示打开连接，收到的数据可以传递给用户。连接的数据传输阶段的正常状态。FIN-WAIT-1表示等待来自远程TCP的连接终止请求，或者先前发送的连接终止请求的确认。FIN-WAIT-2 - 表示等待来自远程TCP的连接终止请求。CLOSE-WAIT - 表示等待来自本地用户的连接终止请求。CLOSING - 表示等待来自远程TCP的连接终止请求确认。LAST-ACK-表示等待先前发送到远程TCP的连接终止请求的确认（其包括对其连接终止请求的确认）。TIME-WAIT - 表示等待足够的时间通过，以确保远程TCP接收到其连接终止请求的确认。CLOSED - 根本不表示连接状态。 TCP连接响应事件从一个状态进行到另一个状态。事件是用户调用，OPEN，SEND，RECEIVE，CLOSE，ABORT和STATUS; 传入段，特别是包含SYN，ACK，RST和FIN标志的段; 和超时。 连接建立和终止 建立连接 只有在两个机器之间的连接不存在，两个机器都同意连接，并且两个机器都有足够的TCP资源来为连接提供服务时，才能在两台机器之间建立连接。如果不满足这些条件中的任何一个，则不能进行连接。连接的接受可以由应用或系统管理例程触发。 数据传输 对于由机器A的TCP从ULP接收的每个数据块，TCP封装它并且以递增的序列号将其发送到机器B. 在机器B接收到消息之后，它使用增加下一个序列号的分段确认来确认它（并且因此指示它接收到该序列号的一切）。 tcp传输图 TCP数据传输服务实际上体现了六个不同的子服务： 全双工：使连接的两端在任何时间，甚至同时发送。 及时性：使用计时器可确保在合理的时间内传输数据。 有序：从一个应用程序发送的数据将在另一端以相同的顺序接收。这发生，尽管事实上数据报可能通过IP被无序地接收，因为TCP在将消息传递到较高层之前以正确的顺序重新组装消息。 标签：所有连接具有商定的优先级和安全值。 受控流：TCP可以通过使用缓冲区和窗口限制来调节信息流。 错误校正：校验和确保数据没有错误（在校验和算法的限制内）。 关闭连接为了关闭连接，TCP之一从ULP接收关闭原语并发出具有设置为开的FIN标志的消息。 tcp关闭连接示意图 在图中，机器A的TCP发送请求以关闭具有下一个序列号的机器B的连接。机器B然后将发送对该请求及其下一个序列号的确认。随后，机器B通过其ULP将关闭消息发送到应用程序，并等待应用程序确认关闭。这一步不是绝对必要的; TCP可以在没有应用程序批准的情况下关闭连接，但是一个良好的系统会通知应用程序状态的改变 UDP什么是UDP UDP是无连接和不可靠的传输协议。两个端口用于标识源和目标机器内的端点。当不需要可靠的传递时，使用用户数据报协议来代替TCP。然而，UDP从不用于发送诸如网页，数据库信息等重要数据。流式媒体例如视频，音频和其他使用UDP因为它提供速度。 UDP的特性 端到端。UDP可以识别在计算机上运行的特定进程。 不可靠，无连接传递（例如USPS:UDP使用无连接通信设置。在这个UDP中不需要在发送数据之前建立连接。通信仅由数据段本身组成）。 与IP相同的尽力语义 无ack，无序列，无流量控制 丢失，复制，延迟，无序或丢失连接 快速，低开销 因为以上特性udp更适合: 适合可靠的本地网络 RTP（实时传输协议 摘要UDP是传输层协议。UDP是一种无连接和不可靠的协议。UDP不做流量控制，错误控制或重传坏段。UDP比TCP快。UDP通常用于流音频和视频。UDP从未用于重要的文档，如网页，数据库信息等。UDP传输由8字节头组成的段。它包含源端口，目标端口，UDP长度和校验和。UDP校验和用于检测传输段中的“错误”。 TCP VS UDP 用户数据报协议（UDP）和传输控制协议（TCP）是TCP / IP协议组中传输层的“同级”。它们执行相同的角色，提供应用程序和Internet协议（IP）的数据移动功能之间的接口，但是它们以非常不同的方式实现。因此，这两种协议为高层协议提供了选择，允许每个协议根据其需要选择适当的协议。 有助于说明这两种协议的最重要的基本属性以及它们如何彼此对比的表： tcp&udp比较图","categories":[{"name":"网络协议","slug":"网络协议","permalink":"http://fudali.cc/categories/网络协议/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"},{"name":"网络","slug":"网络","permalink":"http://fudali.cc/tags/网络/"},{"name":"tcp/ip","slug":"tcp-ip","permalink":"http://fudali.cc/tags/tcp-ip/"}]},{"title":"排序-归并排序","slug":"merge-sort","date":"2017-03-16T16:00:00.000Z","updated":"2017-03-18T08:53:30.000Z","comments":true,"path":"2017/03/17/merge-sort/","link":"","permalink":"http://fudali.cc/2017/03/17/merge-sort/","excerpt":"","text":"前言归并排序体现了递归分治的策略思想是将数组拆分为两段，在对两段进行想通操作，直到数组元素为1，在对数组进行排序合并 代码go12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mergefunc mergeSort(array []int) []int &#123; middle := len(array) / 2 if middle == 1 &#123; return array &#125; return merge(mergeSort(array[:middle]), mergeSort(array[middle:]))&#125;// TODO 待改善func merge(a1 []int, a2 []int) []int &#123; a1Index := 0 a2Index := 0 resIndex := 0 resLen := len(a1) + len(a2) res := make([]int, resLen) for i := 0; i &lt; resLen; i++ &#123; if a1Index == len(a1)-1 &#123; for ; a2Index &lt; len(a2); a2Index++ &#123; res[resIndex] = a2[a2Index] resIndex++ &#125; break &#125; if a2Index == len(a1)-1 &#123; for ; a1Index &lt; len(a1); a1Index++ &#123; res[resIndex] = a1[a1Index] resIndex++ &#125; break &#125; if a1[a1Index] &lt; a2[a2Index] &#123; res[resIndex] = a1[a1Index] a1Index++ &#125; else &#123; res[resIndex] = a2[a2Index] a2Index++ &#125; resIndex++ &#125; return res&#125; golang code in github 总结虽然归并排序的运行时间是O(NlogN)，但是他合并两个已排序数组到一个附加数组会更占用内存。 与其他O(NlogN)的流行算法相比，归并排序是比较元素最少的，且运行时间严重依赖于比较元素和在数组(已经临时数组)中移动元素的开销。 这些开销是于语言相关的(java中泛型数组中的元素是引用类型的，顾移动元素开销不大，所以归并排序是java泛型数组的默认排序方式。 快速排序作为基础类型的排序方式，java基础类型是值传递的，因为比较与数据移动的开销是类似的，快排使用少得多的数据移动足以补偿那些附加的比较而且还有盈余)。 在go中也存在相同的问题，所以在不同的输入数据选择不同的排序方式再能得到最好的性能。","categories":[{"name":"算法","slug":"算法","permalink":"http://fudali.cc/categories/算法/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"排序","slug":"排序","permalink":"http://fudali.cc/tags/排序/"},{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"}]},{"title":"排序-快速排序","slug":"quick-sort","date":"2017-03-16T16:00:00.000Z","updated":"2017-03-18T08:54:37.000Z","comments":true,"path":"2017/03/17/quick-sort/","link":"","permalink":"http://fudali.cc/2017/03/17/quick-sort/","excerpt":"","text":"前言代码go12 总结","categories":[{"name":"算法","slug":"算法","permalink":"http://fudali.cc/categories/算法/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"排序","slug":"排序","permalink":"http://fudali.cc/tags/排序/"},{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"}]},{"title":"排序-希尔排序","slug":"shell-sort","date":"2017-03-14T16:00:00.000Z","updated":"2017-03-18T08:53:37.000Z","comments":true,"path":"2017/03/15/shell-sort/","link":"","permalink":"http://fudali.cc/2017/03/15/shell-sort/","excerpt":"","text":"前言个人认为希尔排序是对插入排序的一种优化，他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序)。所以希尔排序也称为缩减增量排序他相比插入排序所在的优势是，他可以一次交换两个较远距离的元素，而插入排序交换两个相聚n的元素位子需要n次交换。 因为他根据一个算法来决定每趟比较的距离，所以该算法的好坏也会在一定程度上决定希尔排序的性能 代码go123456789101112131415161718192021222324package main// 利用每次除以2的等比增量数列来决定每趟比较距离func sort(array []int) &#123; n := 0 arrayLen := len(array) for gap := arrayLen / 2; gap &gt; 0; gap /= 2 &#123; for i := gap; i &lt; arrayLen; i++ &#123; iv := array[i] for j := i; j-gap &gt; 0 &amp;&amp; array[j-gap] &gt; iv; j -= gap &#123; n++ array[j-gap], array[j] = iv, array[j-gap] &#125; &#125; &#125; println(&quot;---------------&quot;, n)&#125;func main() &#123; array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125; sort(array) for _, v := range array &#123; println(v) &#125;&#125; golang code in github 总结希尔排序的性能在实践中的性能是完全可以接受的；使用希尔增量是最坏情形运行时间复杂度为O(N^2)对于好的增量序列，最坏时间复杂度还可以优化 编程的简单特点，使它成为对适度的大量输入数据进行排序的常用算法","categories":[{"name":"算法","slug":"算法","permalink":"http://fudali.cc/categories/算法/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"排序","slug":"排序","permalink":"http://fudali.cc/tags/排序/"},{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"}]},{"title":"排序-插入排序","slug":"insertion-sort","date":"2017-03-12T16:00:00.000Z","updated":"2017-03-18T08:53:18.000Z","comments":true,"path":"2017/03/13/insertion-sort/","link":"","permalink":"http://fudali.cc/2017/03/13/insertion-sort/","excerpt":"","text":"前言 - 今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模式方面的知识 - 今天就想来理解一下排序算法中最简单的插入排序： 插入排序思路为顺序遍历数组，并在遍历中从顺序遍历到的元素倒序遍历回 倒序遍历是判断相邻两个元素是否符合排序规则 如果符合则停止倒序遍历 如果不符合则交换相邻两个元素位置并继续倒序遍历 代码实现go12345678910111213141516171819202122232425262728ppackage mainfunc sort(array []int) &#123; n := 0 // 从1开始遍历,因为0前面没有数值 for i := 1; i &lt; len(array); i++ &#123; // 在此处放置与在 代码1 处放置效果一样 // 因为若 jv &gt; iv 的话 ， j 与 j-1 调换位置， 下一次循环时 array[j] 依然是当初的 iv iv := array[i] for j := i; j &gt;= 0 &amp;&amp; array[j-1] &gt;= iv; j-- &#123; // 代码1 iv := array[j] // 如果 jv &gt; iv , 调换两个元素之间的位置 n++ array[j], array[j-1] = array[j-1], iv &#125; &#125; println(&quot;----------------&quot;, n)&#125;func main() &#123; array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125; sort(array) for _, v := range array &#123; println(v) &#125;&#125; golang code in github java 123456789101112131415161718192021222324252627282930public class Insertion &#123; public static void main(String[] args) &#123; Integer[] oo = new Integer[]&#123;34, 8, 64, 51, 32, 21&#125;; sort(oo); for (Integer var : oo) &#123; System.out.println(var); &#125; &#125; public static &lt;T&gt; void sort(T[] array) &#123; for (int i = 1; i&lt; array.length; i++) &#123; T it = array[i]; for (int j = i; j &gt; 0; j--) &#123; T jt = array[j - 1]; if (compare(jt, it) &lt; 0) &#123; break; &#125;else &#123; array[j] = jt; array[j - 1] = it; &#125; &#125; &#125; &#125; public static &lt;T&gt; int compare(T o1, T o2) &#123; return (Integer)o1 - (Integer)o2; &#125;&#125; java code in github 总结从原理和显示方式可以看出，当数组本就按排序规则排好序时，时间复杂度最小为 O(N)；当数组为倒序时未最坏情况，测试时间复杂度为O(N^2)当数组中根据排序规则倒序的元素对越多，时间复杂度越大，当数组根据排序规则完全倒序时，时间复杂度最大为 2+3+4+…+N = O(N)","categories":[{"name":"算法","slug":"算法","permalink":"http://fudali.cc/categories/算法/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"排序","slug":"排序","permalink":"http://fudali.cc/tags/排序/"},{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"}]},{"title":"beego upsert 方法原理","slug":"beego-upsert-method","date":"2016-12-12T16:00:00.000Z","updated":"2017-03-18T04:52:13.000Z","comments":true,"path":"2016/12/13/beego-upsert-method/","link":"","permalink":"http://fudali.cc/2016/12/13/beego-upsert-method/","excerpt":"","text":"前言 在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂只支持mysql与postgres。实现原理是数据自带可实现insertorupdate的功能语句。mysql：ON DUPLICATE KEY UPDATEpostgres : ON CONFLICT DO UPDATE SET然后去orm实现中自己拼装sql语句 code 好了，亮代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788func (d *dbBase) InsertOrUpdate(q dbQuerier, mi *modelInfo,ind reflect.Value, tz *time.Location, dn string, args ...string) (int64, error) &#123; iouStr := &quot;&quot; mysql := &quot;mysql&quot; postgres := &quot;postgres&quot; argsMap := map[string]string&#123;&#125; if dn == mysql &#123; iouStr = &quot;ON DUPLICATE KEY UPDATE&quot; &#125; else if dn == postgres &amp;&amp; len(args) &gt; 0 &#123; args0 = args[0] iouStr = fmt.Sprintf(&quot;ON CONFLICT (%s) DO UPDATE SET&quot;, args0) &#125; else &#123; return 0, fmt.Errorf(&quot;`%s` nonsupport insert or update in beego&quot;, dn) &#125; for _, v := range args &#123; kv := strings.Split(v, &quot;=&quot;) if len(kv) == 2 &#123; argsMap[kv[0]] = kv[1] &#125; &#125; isMulti := false names := make([]string, 0, len(mi.fields.dbcols)-1) Q := d.ins.TableQuote() values, err := d.collectValues(mi, ind, mi.fields.dbcols, true, true, &amp;names, tz) if err != nil &#123; return 0, err marks := make([]string, len(names)) updateValues := make([]interface&#123;&#125;, 0) updates := make([]string, len(names)) var conflitValue interface&#123;&#125; for i, v := range names &#123; marks[i] = &quot;?&quot; valueStr := argsMap[v] if v == args0 &#123; conflitValue = values[i] &#125; if valueStr != &quot;&quot; &#123; switch dn &#123; case mysql: updates[i] = v + &quot;=&quot; + valueStr break case postgres: if conflitValue != nil &#123; updates[i] = fmt.Sprintf(&quot;%s=(select %s from %s where %s = ? )&quot;, v, valueStr, mi.table, args[0]) updateValues = append(updateValues, conflitValue) &#125; else &#123; return 0, fmt.Errorf(&quot;`%s` must be in front of `%s` in your struct&quot;, args[0], v) &#125; break &#125; &#125; else &#123; updates[i] = v + &quot;=?&quot; updateValues = append(updateValues, values[i]) &#125; values = append(values, updateValues...) sep := fmt.Sprintf(&quot;%s, %s&quot;, Q, Q) qmarks := strings.Join(marks, &quot;, &quot;) qupdates := strings.Join(updates, &quot;, &quot;) columns := strings.Join(names, sep) multi := len(values) / len(names) if isMulti &#123; qmarks = strings.Repeat(qmarks+&quot;), (&quot;, multi-1) + qmarks &#125; query := fmt.Sprintf(&quot;INSERT INTO %s%s%s (%s%s%s) VALUES (%s) %s &quot;+qupdates, Q, mi.table, Q, Q, columns, Q, qmarks, iouStr) if isMulti || !d.ins.HasReturningID(mi, &amp;query) &#123; res, err := q.Exec(query, values...) if err == nil &#123; if isMulti &#123; return res.RowsAffected() &#125; return res.LastInsertId() &#125; return 0, err &#125; row := q.QueryRow(query, values...) var id int64 err = row.Scan(&amp;id) return id, err&#125; 这就是实现功能的全部逻辑，当然要想在beego orm中使用insertorupdate还有一些其他的工作要做，首先这段代码应该添加在 beego/orm文件夹下的db.go文件中 然后在 orm.go 文件中添加 12345678910 func (o *orm) InsertOrUpdate(md interface&#123;&#125;,colConflitAndArgs ...string) (int64, error) &#123; mi, ind := o.getMiInd(md, true) id, err := o.alias.DbBaser.InsertOrUpdate(o.db, mi, ind, o.alias.TZ, o.alias.DriverName, colConflitAndArgs...) if err != nil &#123; return id, err &#125; o.setPk(mi, ind, id) return id, nil&#125; 123再在types.go文件中的type Ormer interface和type dbBaser interface中分别添加InsertOrUpdate(md interface&#123;&#125;, colConflitAndArgs ...string) (int64, error) 与InsertOrUpdate(dbQuerier, *modelInfo, reflect.Value, *time.Location, string, ...string) (int64, error) 好了，现在大功告成了。可以使用InssertOrUpdate功能了列如： mysql1234567891011121314mysql：func IOUFinish(all *Finish) int64 &#123; db := orm.NewOrm() db.Using(&quot;mysql&quot;) r, e := db.InsertOrUpdate(all, &quot;step=step+1&quot;) if e != nil &#123; fmt.Println(e) return 0 &#125; fmt.Println(r) return r&#125; 这个函数在出入数据时有主键或者唯一键冲突，将执行update操作，其中step列执行+自增操作，其他列按model中的值进行update操作。其中”step=step+1”格式数据可以有多个也可以没有，这种格式只用于自增操作 postgresql1234567891011121314postgres：func IOUFinish(all *Finish) int64 &#123; db := orm.NewOrm() db.Using(&quot;postgres&quot;) r, e := db.InsertOrUpdate(all,&quot;confilctColumnName&quot; &quot;step=step+1&quot;) if e != nil &#123; fmt.Println(e) return 0 &#125; fmt.Println(r) return r&#125; 当操作postgres数据库是，必须在model后的第一个参数指定你预期的冲突列的列名(由于实现此功能的sql语句需要且数据库版本必须大于9.5，因为实现的语句由9.5版本推出)，其他与mysql一致。 提示：在使用自增操作是最好不要自增主键或者唯一键，可能会引起错误。","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://fudali.cc/categories/开源项目/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"beego","slug":"beego","permalink":"http://fudali.cc/tags/beego/"}]},{"title":"go 1.6.2 strings split 方法改造","slug":"go1.6.2-strings-split","date":"2016-12-12T16:00:00.000Z","updated":"2017-03-18T04:55:31.000Z","comments":true,"path":"2016/12/13/go1.6.2-strings-split/","link":"","permalink":"http://fudali.cc/2016/12/13/go1.6.2-strings-split/","excerpt":"","text":"当调用strings.Split(s,seq string)时,如果seq连续出现，比如s=&quot; dfdgdfg （多个空格） dfdg （多个空格） hghyjkjuyk &quot;。调用slice:=strings.Split(s,&quot; &quot;)将会出现len(slice)!=3，我认为这并不是大家希望看到的结果。 查看strings.Split(s,seq string)源码：func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) } 接着查看strings.genSplit()源码：12345678910111213141516171819202122232425func genSplit(s, sep string, sepSave, n int) []string &#123; if n == 0 &#123; return nil &#125; if sep == &quot;&quot; &#123; return explode(s, n) &#125; if n &lt; 0 &#123; n = Count(s, sep) + 1 &#125; c := sep[0] start := 0 a := make([]string, n) na := 0 for i := 0; i+len(sep) &lt;= len(s) &amp;&amp; na+1 &lt; n; i++ &#123; if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123; a[na] = s[start : i+sepSave] na++ start = i + len(sep) i += len(sep) - 1 &#125; &#125; a[na] = s[start:] return a[0 : na+1]&#125; 发现并没有做相关的判断就将s[start : i+sepSave]添加到返回数组造成出现这种情况； 顾在for循环中添加一个判断以达到预期返回值，代码如下：123456789if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123; splitStr:=s[start : i+sepSave] if !(splitStr == sep || start==i+sepSave) &#123; a[na] = splitStr na++ &#125; start = i + len(sep) i += len(sep) - 1&#125; 之后调用即可达到预期返回值","categories":[{"name":"golang笔记","slug":"golang笔记","permalink":"http://fudali.cc/categories/golang笔记/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"}]},{"title":"ELK学习之安装logstash","slug":"ELK-install-logstash","date":"2016-02-15T16:00:00.000Z","updated":"2017-03-18T05:27:54.000Z","comments":true,"path":"2016/02/16/ELK-install-logstash/","link":"","permalink":"http://fudali.cc/2016/02/16/ELK-install-logstash/","excerpt":"","text":"下载安装 logstash基于jvm平台，所以安装前确认已安装jre 最新的logstash 5.*版本至少需要java8以上jre 对于Debian平台或者Redhat平台,官方推荐配置软件仓库并安装 Debian/Ubuntu 平台123456wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | apt-key add -cat &gt;&gt; /etc/apt/sources.list &lt;&lt;EOFdeb http://packages.elasticsearch.org/logstash/5.0/debian stable mainEOFapt-get updateapt-get install logstash 一行一行复制输入命令行即可 有可能出现如下错误(也有可能是运行时出现)1Could not find any executable java binary. Please install java in your PATH or set JAVA_HOME. 此时需要修改logstash的启动配置文件，对Debian/Ubuntu系统，该文件路径为/etc/logstash/startup.options，其中的JAVACMD参数默认为/usr/**,顾导致找不到java命令，只需将改参数改为你的$JAVA_HOME/bin/java即可解决该错误 运行软件仓库安装后logstash bin所在路径为/usr/share/logstash 直接运行简单命令行输入input1bin/logstash -e &apos;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&apos; 配置文件运行 1bin/logstash -f &#123;配置文件路径&#125;","categories":[{"name":"日志收集","slug":"日志收集","permalink":"http://fudali.cc/categories/日志收集/"}],"tags":[{"name":"ELK","slug":"ELK","permalink":"http://fudali.cc/tags/ELK/"},{"name":"logstash","slug":"logstash","permalink":"http://fudali.cc/tags/logstash/"}]}]}