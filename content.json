{"meta":{"title":"fudali","subtitle":"do one`s best","description":"do one`s best","author":"fudali","url":"http://fudali.cc"},"pages":[{"title":"","date":"2017-03-17T08:41:11.000Z","updated":"2017-03-17T08:41:11.000Z","comments":false,"path":"categories/index.html","permalink":"http://fudali.cc/categories/index.html","excerpt":"","text":""},{"title":"doob入门","date":"2016-01-12T16:00:00.000Z","updated":"2017-01-13T09:46:45.000Z","comments":true,"path":"doob/doob_get_start.html","permalink":"http://fudali.cc/doob/doob_get_start.html","excerpt":"","text":"快速开始下载依赖1go get github.com/fudali113/doob 创建main函数文件demo.go1234567891011121314package mainimport &quot;github.com/fudali113/doob&quot;func main() &#123; doob.Start(8888)&#125;func init()&#123; router := doob.DefaultRouter() router.Get(&quot;/test&quot;, func (ctx *doob.Context) interface&#123;&#125; &#123; return &quot;test&quot; &#125;)&#125; 编译运行1go run demo.go 浏览效果打开浏览器并访问 http://localhost:8888/test"},{"title":"关于我","date":"2016-12-12T16:00:00.000Z","updated":"2017-03-17T09:39:12.000Z","comments":true,"path":"about/index.html","permalink":"http://fudali.cc/about/index.html","excerpt":"","text":"hi, i am a sunshine boy ^_^ my cool photo loading error These are my hobby: sports , basketball coding running beautiful girl fork me github"},{"title":"","date":"2017-03-17T08:40:51.000Z","updated":"2017-03-17T08:40:51.000Z","comments":false,"path":"tags/index.html","permalink":"http://fudali.cc/tags/index.html","excerpt":"","text":""},{"title":"doob doc","date":"2017-03-09T16:00:00.000Z","updated":"2017-03-17T09:39:22.000Z","comments":true,"path":"doob/index.html","permalink":"http://fudali.cc/doob/index.html","excerpt":"","text":"docget start get start 简单的使用并运行起来 使用"},{"title":"go错误类型","date":"2016-03-15T16:00:00.000Z","updated":"2017-03-17T09:37:26.000Z","comments":true,"path":"note/go_error.html","permalink":"http://fudali.cc/note/go_error.html","excerpt":"","text":"引包错误12use of package sort without selector该错误出现在引入报名与当前包中定义的变量或函数重名"},{"title":"","date":"2017-03-17T16:08:53.000Z","updated":"2017-03-17T16:08:53.000Z","comments":true,"path":"note/http.html","permalink":"http://fudali.cc/note/http.html","excerpt":"","text":"Transfer-Encoding: chunked客服端将分段解析tcp发送的数据，以0结尾"}],"posts":[{"title":"tcp和udp网络协议","slug":"tcp-and-udp-protocols","date":"2017-03-16T16:00:00.000Z","updated":"2017-03-17T17:00:35.000Z","comments":true,"path":"2017/03/17/tcp-and-udp-protocols/","link":"","permalink":"http://fudali.cc/2017/03/17/tcp-and-udp-protocols/","excerpt":"","text":"简介TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，UDP是无连接的协议。 什么是TCP 是传输层的一种面向连接的协议 处理下层的不可靠数据使之变得可靠(确定通过网络发送的数据报的状态并且如果部分已被丢弃则处理信息的重发的任务并按正确的顺序重新组合成消息以提供可靠性) TCP驻留在传输层中，并仅驻留在实际处理数据报的机器上，确保数据报已从源机器到目标机器；它不驻留在简单路由数据报的设备上，因此网关中没有TCP层。 加载失败 TCP的特点 单播协议:TCP基于单播网络模型，支持两方之间的数据交换。它不支持广播或多播网络模型。 连接状态:TCP使用两个端点之间的同步状态，而不是在网络内强加一个状态来支持连接。该同步状态被设置为初始连接过程的一部分，因此TCP可以被认为是面向连接的协议。许多协议设计旨在确保每个本地状态转换被传送到远程方并由其确认。 可靠性: 可靠性意味着在连接的一端传递给TCP驱动程序的八位字节流将通过网络传输，使得流作为相同的八位字节序列呈现给远程进程，顺序与生成的由发送方。这意味着协议检测数据流的分段何时已被网络丢弃，重新排序，复制或损坏。在必要的情况下，发送器将重传损坏的段，以便允许接收器重建原始数据流。这意味着TCP发送方必须保持所有发送数据的本地副本，直到它接收到接收方已经完成数据的准确传送的指示为止。 全双工: TCP是全双工协议; 它允许双方在单个TCP连接的上下文内发送和接收数据。 流: 虽然TCP使用分组结构用于网络传输，但TCP是真正的流传输协议，并且应用级网络操作不透明。一些协议明确地封装每个应用事务;对于每一次写，都必须有一个匹配的读。以这种方式，在网络上保留数据流到逻辑记录结构的应用派生分段。TCP不保留施加在数据流上的这种隐式结构，使得在网络协议内的写和读操作之间不存在配对。例如，TCP应用可以将三个数据块按顺序写入网络连接，其可以由远程读取器在单个读取操作中收集。TCP会话中使用的数据块（段）的大小在会话开始时协商。发送器尝试在接收器的最大段大小，配置的发送器的最大段大小和最大可支持的非分段分组大小的限制内使用它可以用于数据传输的最大段大小网络路径（路径最大传输单元[MTU]）。路径MTU周期性地刷新以适应在TCP连接活动时可能发生在网络内的任何改变。 速率适配: TCP也是速率自适应协议，因为数据传输速率旨在适应网络内的主要负载条件并适应接收机的处理能力。没有预定的TCP数据传输速率; 如果网络和接收器都具有额外的可用容量，则TCP发送器将尝试向网络注入更多数据以占用此可用空间。相反，如果有拥塞，TCP发送方将降低其发送速率以允许网络恢复。该适配功能试图实现最高可能的数据传输速率，而不触发一致的数据丢失。","categories":[{"name":"简介","slug":"简介","permalink":"http://fudali.cc/categories/简介/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"},{"name":"网络","slug":"网络","permalink":"http://fudali.cc/tags/网络/"},{"name":"tcp/ip","slug":"tcp-ip","permalink":"http://fudali.cc/tags/tcp-ip/"}]},{"title":"排序-希尔排序","slug":"shell-sort","date":"2017-03-14T16:00:00.000Z","updated":"2017-03-17T09:38:34.000Z","comments":true,"path":"2017/03/15/shell-sort/","link":"","permalink":"http://fudali.cc/2017/03/15/shell-sort/","excerpt":"","text":"前言个人认为希尔排序是对插入排序的一种优化，他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序)。所以希尔排序也称为缩减增量排序他相比插入排序所在的优势是，他可以一次交换两个较远距离的元素，而插入排序交换两个相聚n的元素位子需要n次交换。 因为他根据一个算法来决定每趟比较的距离，所以该算法的好坏也会在一定程度上决定希尔排序的性能 代码go123456789101112131415161718192021222324package main// 利用每次除以2的等比增量数列来决定每趟比较距离func sort(array []int) &#123; n := 0 arrayLen := len(array) for gap := arrayLen / 2; gap &gt; 0; gap /= 2 &#123; for i := gap; i &lt; arrayLen; i++ &#123; iv := array[i] for j := i; j-gap &gt; 0 &amp;&amp; array[j-gap] &gt; iv; j -= gap &#123; n++ array[j-gap], array[j] = iv, array[j-gap] &#125; &#125; &#125; println(&quot;---------------&quot;, n)&#125;func main() &#123; array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125; sort(array) for _, v := range array &#123; println(v) &#125;&#125; golang code in github 总结","categories":[{"name":"前言","slug":"前言","permalink":"http://fudali.cc/categories/前言/"},{"name":"代码实现 - go","slug":"前言/代码实现-go","permalink":"http://fudali.cc/categories/前言/代码实现-go/"},{"name":"总结","slug":"前言/代码实现-go/总结","permalink":"http://fudali.cc/categories/前言/代码实现-go/总结/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"排序","slug":"排序","permalink":"http://fudali.cc/tags/排序/"},{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"}]},{"title":"排序-插入排序","slug":"insertion-sort","date":"2017-03-12T16:00:00.000Z","updated":"2017-03-17T09:36:43.000Z","comments":true,"path":"2017/03/13/insertion-sort/","link":"","permalink":"http://fudali.cc/2017/03/13/insertion-sort/","excerpt":"","text":"前言 - 今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模式方面的知识 - 今天就想来理解一下排序算法中最简单的插入排序： 插入排序思路为顺序遍历数组，并在遍历中从顺序遍历到的元素倒序遍历回 倒序遍历是判断相邻两个元素是否符合排序规则 如果符合则停止倒序遍历 如果不符合则交换相邻两个元素位置并继续倒序遍历 代码实现go12345678910111213141516171819202122232425262728ppackage mainfunc sort(array []int) &#123; n := 0 // 从1开始遍历,因为0前面没有数值 for i := 1; i &lt; len(array); i++ &#123; // 在此处放置与在 代码1 处放置效果一样 // 因为若 jv &gt; iv 的话 ， j 与 j-1 调换位置， 下一次循环时 array[j] 依然是当初的 iv iv := array[i] for j := i; j &gt;= 0 &amp;&amp; array[j-1] &gt;= iv; j-- &#123; // 代码1 iv := array[j] // 如果 jv &gt; iv , 调换两个元素之间的位置 n++ array[j], array[j-1] = array[j-1], iv &#125; &#125; println(&quot;----------------&quot;, n)&#125;func main() &#123; array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125; sort(array) for _, v := range array &#123; println(v) &#125;&#125; golang code in github java 123456789101112131415161718192021222324252627282930public class Insertion &#123; public static void main(String[] args) &#123; Integer[] oo = new Integer[]&#123;34, 8, 64, 51, 32, 21&#125;; sort(oo); for (Integer var : oo) &#123; System.out.println(var); &#125; &#125; public static &lt;T&gt; void sort(T[] array) &#123; for (int i = 1; i&lt; array.length; i++) &#123; T it = array[i]; for (int j = i; j &gt; 0; j--) &#123; T jt = array[j - 1]; if (compare(jt, it) &lt; 0) &#123; break; &#125;else &#123; array[j] = jt; array[j - 1] = it; &#125; &#125; &#125; &#125; public static &lt;T&gt; int compare(T o1, T o2) &#123; return (Integer)o1 - (Integer)o2; &#125;&#125; java code in github 总结从原理和显示方式可以看出，当数组本就按排序规则排好序时，时间复杂度最小为 O(N)当数组中根据排序规则倒序的元素对越多，时间复杂度越大，当数组根据排序规则完全倒序时，时间复杂度最大为 2+3+4+…+N = O(N)","categories":[{"name":"前言 - 1 - 2","slug":"前言-1-2","permalink":"http://fudali.cc/categories/前言-1-2/"},{"name":"代码实现 - go - java","slug":"前言-1-2/代码实现-go-java","permalink":"http://fudali.cc/categories/前言-1-2/代码实现-go-java/"},{"name":"总结","slug":"前言-1-2/代码实现-go-java/总结","permalink":"http://fudali.cc/categories/前言-1-2/代码实现-go-java/总结/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"排序","slug":"排序","permalink":"http://fudali.cc/tags/排序/"},{"name":"学习","slug":"学习","permalink":"http://fudali.cc/tags/学习/"}]},{"title":"beego upsert 方法原理","slug":"beego-upsert-method","date":"2016-12-12T16:00:00.000Z","updated":"2017-03-17T09:39:02.000Z","comments":true,"path":"2016/12/13/beego-upsert-method/","link":"","permalink":"http://fudali.cc/2016/12/13/beego-upsert-method/","excerpt":"","text":"前言 在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂只支持mysql与postgres。实现原理是数据自带可实现insertorupdate的功能语句。mysql：ON DUPLICATE KEY UPDATEpostgres : ON CONFLICT DO UPDATE SET然后去orm实现中自己拼装sql语句 code 好了，亮代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788func (d *dbBase) InsertOrUpdate(q dbQuerier, mi *modelInfo,ind reflect.Value, tz *time.Location, dn string, args ...string) (int64, error) &#123; iouStr := &quot;&quot; mysql := &quot;mysql&quot; postgres := &quot;postgres&quot; argsMap := map[string]string&#123;&#125; if dn == mysql &#123; iouStr = &quot;ON DUPLICATE KEY UPDATE&quot; &#125; else if dn == postgres &amp;&amp; len(args) &gt; 0 &#123; args0 = args[0] iouStr = fmt.Sprintf(&quot;ON CONFLICT (%s) DO UPDATE SET&quot;, args0) &#125; else &#123; return 0, fmt.Errorf(&quot;`%s` nonsupport insert or update in beego&quot;, dn) &#125; for _, v := range args &#123; kv := strings.Split(v, &quot;=&quot;) if len(kv) == 2 &#123; argsMap[kv[0]] = kv[1] &#125; &#125; isMulti := false names := make([]string, 0, len(mi.fields.dbcols)-1) Q := d.ins.TableQuote() values, err := d.collectValues(mi, ind, mi.fields.dbcols, true, true, &amp;names, tz) if err != nil &#123; return 0, err marks := make([]string, len(names)) updateValues := make([]interface&#123;&#125;, 0) updates := make([]string, len(names)) var conflitValue interface&#123;&#125; for i, v := range names &#123; marks[i] = &quot;?&quot; valueStr := argsMap[v] if v == args0 &#123; conflitValue = values[i] &#125; if valueStr != &quot;&quot; &#123; switch dn &#123; case mysql: updates[i] = v + &quot;=&quot; + valueStr break case postgres: if conflitValue != nil &#123; updates[i] = fmt.Sprintf(&quot;%s=(select %s from %s where %s = ? )&quot;, v, valueStr, mi.table, args[0]) updateValues = append(updateValues, conflitValue) &#125; else &#123; return 0, fmt.Errorf(&quot;`%s` must be in front of `%s` in your struct&quot;, args[0], v) &#125; break &#125; &#125; else &#123; updates[i] = v + &quot;=?&quot; updateValues = append(updateValues, values[i]) &#125; values = append(values, updateValues...) sep := fmt.Sprintf(&quot;%s, %s&quot;, Q, Q) qmarks := strings.Join(marks, &quot;, &quot;) qupdates := strings.Join(updates, &quot;, &quot;) columns := strings.Join(names, sep) multi := len(values) / len(names) if isMulti &#123; qmarks = strings.Repeat(qmarks+&quot;), (&quot;, multi-1) + qmarks &#125; query := fmt.Sprintf(&quot;INSERT INTO %s%s%s (%s%s%s) VALUES (%s) %s &quot;+qupdates, Q, mi.table, Q, Q, columns, Q, qmarks, iouStr) if isMulti || !d.ins.HasReturningID(mi, &amp;query) &#123; res, err := q.Exec(query, values...) if err == nil &#123; if isMulti &#123; return res.RowsAffected() &#125; return res.LastInsertId() &#125; return 0, err &#125; row := q.QueryRow(query, values...) var id int64 err = row.Scan(&amp;id) return id, err&#125; 这就是实现功能的全部逻辑，当然要想在beego orm中使用insertorupdate还有一些其他的工作要做，首先这段代码应该添加在 beego/orm文件夹下的db.go文件中 然后在 orm.go 文件中添加 12345678910 func (o *orm) InsertOrUpdate(md interface&#123;&#125;,colConflitAndArgs ...string) (int64, error) &#123; mi, ind := o.getMiInd(md, true) id, err := o.alias.DbBaser.InsertOrUpdate(o.db, mi, ind, o.alias.TZ, o.alias.DriverName, colConflitAndArgs...) if err != nil &#123; return id, err &#125; o.setPk(mi, ind, id) return id, nil&#125; 123再在types.go文件中的type Ormer interface和type dbBaser interface中分别添加InsertOrUpdate(md interface&#123;&#125;, colConflitAndArgs ...string) (int64, error) 与InsertOrUpdate(dbQuerier, *modelInfo, reflect.Value, *time.Location, string, ...string) (int64, error) 好了，现在大功告成了。可以使用InssertOrUpdate功能了列如： mysql1234567891011121314mysql：func IOUFinish(all *Finish) int64 &#123; db := orm.NewOrm() db.Using(&quot;mysql&quot;) r, e := db.InsertOrUpdate(all, &quot;step=step+1&quot;) if e != nil &#123; fmt.Println(e) return 0 &#125; fmt.Println(r) return r&#125; 这个函数在出入数据时有主键或者唯一键冲突，将执行update操作，其中step列执行+自增操作，其他列按model中的值进行update操作。其中”step=step+1”格式数据可以有多个也可以没有，这种格式只用于自增操作 postgresql1234567891011121314postgres：func IOUFinish(all *Finish) int64 &#123; db := orm.NewOrm() db.Using(&quot;postgres&quot;) r, e := db.InsertOrUpdate(all,&quot;confilctColumnName&quot; &quot;step=step+1&quot;) if e != nil &#123; fmt.Println(e) return 0 &#125; fmt.Println(r) return r&#125; 当操作postgres数据库是，必须在model后的第一个参数指定你预期的冲突列的列名(由于实现此功能的sql语句需要且数据库版本必须大于9.5，因为实现的语句由9.5版本推出)，其他与mysql一致。 提示：在使用自增操作是最好不要自增主键或者唯一键，可能会引起错误。","categories":[{"name":"前言","slug":"前言","permalink":"http://fudali.cc/categories/前言/"},{"name":"code - mysql - postgresql","slug":"前言/code-mysql-postgresql","permalink":"http://fudali.cc/categories/前言/code-mysql-postgresql/"}],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"},{"name":"beego","slug":"beego","permalink":"http://fudali.cc/tags/beego/"}]},{"title":"go 1.6.2 strings split 方法改造","slug":"go1.6.2-strings-split","date":"2016-12-12T16:00:00.000Z","updated":"2017-03-17T09:38:50.000Z","comments":true,"path":"2016/12/13/go1.6.2-strings-split/","link":"","permalink":"http://fudali.cc/2016/12/13/go1.6.2-strings-split/","excerpt":"","text":"当调用strings.Split(s,seq string)时,如果seq连续出现，比如s=&quot; dfdgdfg （多个空格） dfdg （多个空格） hghyjkjuyk &quot;。调用slice:=strings.Split(s,&quot; &quot;)将会出现len(slice)!=3，我认为这并不是大家希望看到的结果。 查看strings.Split(s,seq string)源码：func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) } 接着查看strings.genSplit()源码：12345678910111213141516171819202122232425func genSplit(s, sep string, sepSave, n int) []string &#123; if n == 0 &#123; return nil &#125; if sep == &quot;&quot; &#123; return explode(s, n) &#125; if n &lt; 0 &#123; n = Count(s, sep) + 1 &#125; c := sep[0] start := 0 a := make([]string, n) na := 0 for i := 0; i+len(sep) &lt;= len(s) &amp;&amp; na+1 &lt; n; i++ &#123; if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123; a[na] = s[start : i+sepSave] na++ start = i + len(sep) i += len(sep) - 1 &#125; &#125; a[na] = s[start:] return a[0 : na+1]&#125; 发现并没有做相关的判断就将s[start : i+sepSave]添加到返回数组造成出现这种情况； 顾在for循环中添加一个判断以达到预期返回值，代码如下：123456789if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123; splitStr:=s[start : i+sepSave] if !(splitStr == sep || start==i+sepSave) &#123; a[na] = splitStr na++ &#125; start = i + len(sep) i += len(sep) - 1&#125; 之后调用即可达到预期返回值","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://fudali.cc/tags/golang/"}]},{"title":"ELK学习之安装logstash","slug":"ELK_install_logstash","date":"2016-02-15T16:00:00.000Z","updated":"2017-02-17T12:39:56.000Z","comments":true,"path":"2016/02/16/ELK_install_logstash/","link":"","permalink":"http://fudali.cc/2016/02/16/ELK_install_logstash/","excerpt":"","text":"下载安装 logstash基于jvm平台，所以安装前确认已安装jre 最新的logstash 5.*版本至少需要java8以上jre 对于Debian平台或者Redhat平台,官方推荐配置软件仓库并安装 Debian/Ubuntu 平台123456wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | apt-key add -cat &gt;&gt; /etc/apt/sources.list &lt;&lt;EOFdeb http://packages.elasticsearch.org/logstash/5.0/debian stable mainEOFapt-get updateapt-get install logstash 一行一行复制输入命令行即可 有可能出现如下错误(也有可能是运行时出现)1Could not find any executable java binary. Please install java in your PATH or set JAVA_HOME. 此时需要修改logstash的启动配置文件，对Debian/Ubuntu系统，该文件路径为/etc/logstash/startup.options，其中的JAVACMD参数默认为/usr/**,顾导致找不到java命令，只需将改参数改为你的$JAVA_HOME/bin/java即可解决该错误 运行软件仓库安装后logstash bin所在路径为/usr/share/logstash 直接运行简单命令行输入input1bin/logstash -e &apos;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&apos; 配置文件运行 1bin/logstash -f &#123;配置文件路径&#125;","categories":[{"name":"下载安装","slug":"下载安装","permalink":"http://fudali.cc/categories/下载安装/"},{"name":"运行","slug":"下载安装/运行","permalink":"http://fudali.cc/categories/下载安装/运行/"}],"tags":[{"name":"ELK","slug":"ELK","permalink":"http://fudali.cc/tags/ELK/"},{"name":"logstash","slug":"logstash","permalink":"http://fudali.cc/tags/logstash/"}]}]}