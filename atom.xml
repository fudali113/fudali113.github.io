<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fudali</title>
  <subtitle>do one`s best</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fudali.cc/"/>
  <updated>2017-03-25T04:36:59.000Z</updated>
  <id>http://fudali.cc/</id>
  
  <author>
    <name>fudali</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>consul权限控制</title>
    <link href="http://fudali.cc/2017/03/24/consul-acl/"/>
    <id>http://fudali.cc/2017/03/24/consul-acl/</id>
    <published>2017-03-23T16:00:00.000Z</published>
    <updated>2017-03-25T04:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近公司准备实践微服务，在服务发现与注册方面选择了consul；<br>主要是基于易用与功能全面的考虑；</p>
<p>因为之前只是有点点初步的理解，并没有去深入的了解与实践，实践的时候发现consul的权限控制有一点不好理解；<br>所以只有跟我们老大(大波哥)一起去踩坑；</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><p>  consul的acl控制默认是关闭的，需要在任意配置文件中添加<code>acl_master_token</code>配置项<br>  此时默认的控制策略是可写的(<code>acl_default_policy为write</code>)<br>  因为consul默认有匿名token(即<code>anonymous</code>),此token当用户acl开启且用户token为空时默认使用该token<br>  因为此时默认策略为全部可写，此时<code>anonymous</code>也拥有全部的权限包括acl的读写权限<br>  顾想要设置权限控制应该使<code>acl_default_policy为deny</code>，此时默认权限控制为全部否定。</p>
</li>
<li><p>  当配置之后可能会发现打开ui依然可见自己的consul服务，这一点会让人很奇怪，这是consul在检测服务时默认不检测consul服务的权限：</p>
<p>  <code>consul/consul/acl.go#347</code> version：v0.7.5</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// allowService is used to determine if a service is accessible for an ACL.</div><div class="line">func (f *aclFilter) allowService(service string) bool &#123;</div><div class="line">    if service == &quot;&quot; || service == ConsulServiceID &#123;</div><div class="line">        return true</div><div class="line">    &#125;</div><div class="line">    return f.acl.ServiceRead(service)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <a href="https://github.com/hashicorp/consul/issues/2816" target="_blank" rel="external">github issue # 2816</a></p>
<p>  这个貌似可以使使用<code>enforceVersion8</code>进行控制，未实现</p>
</li>
</ul>
<ul>
<li>  对于ui中多次输错token出现403页面，可以使用清除浏览器缓存或者换个浏览器进入ui界面，这应该做的一定的安全举措</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近公司准备实践微服务，在服务发现与注册方面选择了consul；&lt;br&gt;主要是基于易用与功能全面的考虑；&lt;/p&gt;
&lt;p&gt;因为之前只是有点点初
    
    </summary>
    
      <category term="微服务" scheme="http://fudali.cc/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="consul" scheme="http://fudali.cc/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-对顶堆</title>
    <link href="http://fudali.cc/2017/03/22/adt-median-heap/"/>
    <id>http://fudali.cc/2017/03/22/adt-median-heap/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-22T14:58:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对顶堆，用于实时求解中位数<br>用一个最大堆和一个最小堆组成一个结构体<br>对插入元素进行操作并使最大堆元素与最少堆元素最多只能有一个交点(集两个堆顶相等)且保证两个堆的长度差距不能大于1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">package adt</div><div class="line"></div><div class="line">import &quot;log&quot;</div><div class="line"></div><div class="line">// MedianHeap 实时求解中位数堆</div><div class="line">type MedianHeap struct &#123;</div><div class="line">	min *Heap</div><div class="line">	max *Heap</div><div class="line">&#125;</div><div class="line"></div><div class="line">// GetMedianHeap 获取一个中位数堆</div><div class="line">func GetMedianHeap() MedianHeap &#123;</div><div class="line">	return MedianHeap&#123;min: GetHeap(false), max: GetHeap(true)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Len 获取实际长度</div><div class="line">func (mh MedianHeap) Len() int &#123;</div><div class="line">	return mh.min.Len() + mh.max.Len()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Insert 添加一个元素</div><div class="line">func (mh MedianHeap) Insert(value int) &#123;</div><div class="line">	if mh.min.Len() == 0 &#123;</div><div class="line">		mh.min.Insert(value)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	if mh.max.Len() == 0 &#123;</div><div class="line">		minValue, _ := mh.min.Get()</div><div class="line">		if value &gt; minValue &#123;</div><div class="line">			mh.min.Delete()</div><div class="line">			mh.min.Insert(value)</div><div class="line">			mh.max.Insert(minValue)</div><div class="line">		&#125; else &#123;</div><div class="line">			mh.max.Insert(value)</div><div class="line">		&#125;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if mh.insertMin(value) &#123;</div><div class="line">		mh.min.Insert(value)</div><div class="line">	&#125; else &#123;</div><div class="line">		mh.max.Insert(value)</div><div class="line">	&#125;</div><div class="line">	mh.reset()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// GetMedian 实时获取中位数</div><div class="line">func (mh MedianHeap) GetMedian() (median float32) &#123;</div><div class="line">	log.Println(&quot;GetMedian log:&quot;, mh.min, &quot;---&quot;, mh.max)</div><div class="line">	minL, maxL := mh.min.Len(), mh.max.Len()</div><div class="line">	if mh.Len() == 0 &#123;</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	gap := minL - maxL</div><div class="line">	switch gap &#123;</div><div class="line">	case 1:</div><div class="line">		minV, _ := mh.min.Get()</div><div class="line">		median = float32(minV)</div><div class="line">	case 0:</div><div class="line">		minV, _ := mh.min.Get()</div><div class="line">		maxV, _ := mh.max.Get()</div><div class="line">		median = (float32(minV) + float32(maxV)) / 2</div><div class="line">	case -1:</div><div class="line">		maxV, _ := mh.max.Get()</div><div class="line">		median = float32(maxV)</div><div class="line">	default:</div><div class="line">		mh.reset()</div><div class="line">		mh.GetMedian()</div><div class="line">	&#125;</div><div class="line">	return</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (mh MedianHeap) insertMin(value int) bool &#123;</div><div class="line">	minV, _ := mh.min.Get()</div><div class="line">	maxV, _ := mh.max.Get()</div><div class="line">	minL, maxL := mh.min.Len(), mh.max.Len()</div><div class="line">	if value &gt; minV &#123;</div><div class="line">		return true</div><div class="line">	&#125; else if value &gt;= maxV &#123;</div><div class="line">		if minL &gt; maxL &#123;</div><div class="line">			return false</div><div class="line">		&#125;</div><div class="line">		return true</div><div class="line">	&#125;</div><div class="line">	return false</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (mh MedianHeap) reset() &#123;</div><div class="line">	minL, maxL := mh.min.Len(), mh.max.Len()</div><div class="line">	gap := minL - maxL</div><div class="line">	if gap &gt;= 2 &#123;</div><div class="line">		minV, _ := mh.min.Delete()</div><div class="line">		mh.max.Insert(minV)</div><div class="line">	&#125; else if gap &lt;= -2 &#123;</div><div class="line">		maxV, _ := mh.max.Delete()</div><div class="line">		mh.min.Insert(maxV)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/adt/median_head.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TODO</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对顶堆，用于实时求解中位数&lt;br&gt;用一个最大堆和一个最小堆组成一个结构体&lt;br&gt;对插入元素进行操作并使最大堆元素与最少堆元素最多只能有一个交
    
    </summary>
    
      <category term="数据结构" scheme="http://fudali.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ADT" scheme="http://fudali.cc/tags/ADT/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://fudali.cc/2017/03/20/adt-heap/"/>
    <id>http://fudali.cc/2017/03/20/adt-heap/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>堆又称为优先队列，支持插入和删除堆顶操作；<br>分为最小堆、最大堆、还有一种扩展实现对顶堆，常用语实时获取中位数；<br>在贪婪算法的实现即是基于堆，该算法通过反复最小元来进行操作；</p>
<h3 id="下虑插入"><a href="#下虑插入" class="headerlink" title="下虑插入"></a>下虑插入</h3><p>下虑插入主要用在delete操作，此时顶刚好空缺并且堆中少了一个元素,因此现在堆中最后一个元素(暂且命名为X)必须移动到该堆的某个位置。</p>
<p>如果X可以放入堆顶，那么delete操作完成。</p>
<p>但是这一般不太可能，因此我们将空缺位置的两个儿子中优先级(根据最大堆或者最小堆优先级可能不同)更大与空缺位置调换；此时空缺位置被推向想一层。重复改步鄹直到X可以放入空缺位置。</p>
<p>这种一般的策略叫做下虑；<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/percolate-down.jpeg" alt="下虑插入示意图" title="">
                </div>
                <div class="image-caption">下虑插入示意图</div>
            </figure></p>
<h3 id="上虑插入"><a href="#上虑插入" class="headerlink" title="上虑插入"></a>上虑插入</h3><p>上虑插入主要用于insert操作，此时堆中处于平衡状态，因此现在在堆尾建立一个一个空缺位置；</p>
<p>在空缺位置与其父节点进行对比优先级，若插入元素优先级更高，则将空缺位置与父节点调换位置；</p>
<p>此时空缺位置已被推上一层，重复吃步鄹直到找到合适的空缺位置。</p>
<p>这种一般的策略叫做上虑；<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/percolate-up1.jpeg" alt="上虑插入示意图1" title="">
                </div>
                <div class="image-caption">上虑插入示意图1</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/percolate-up2.jpeg" alt="上虑插入示意图2" title="">
                </div>
                <div class="image-caption">上虑插入示意图2</div>
            </figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line">package adt</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// Heap 堆结构</div><div class="line">// 数组形式为index为0的元素默认为空，总index为1元素开始</div><div class="line">// 方便定位元素</div><div class="line">// 即如往堆里插入1,2,3,4,5</div><div class="line">// 数组元素为[0,1,2,3,4,5]</div><div class="line">type Heap struct &#123;</div><div class="line">	array []int</div><div class="line">	isMax bool // 表示最大堆还是最小堆</div><div class="line">&#125;</div><div class="line"></div><div class="line">// GetHeap 获取一个Heap实列</div><div class="line">func GetHeap(isMax bool) *Heap &#123;</div><div class="line">	return &amp;Heap&#123;array: make([]int, 1, 8), isMax: isMax&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Insert 插入一个元素</div><div class="line">func (h *Heap) Insert(value int) &#123;</div><div class="line">	if h.array == nil &#123;</div><div class="line">		h.array = make([]int, 1, 8)</div><div class="line">	&#125;</div><div class="line">	h.array = insert(h.array, value, h.isMax)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Delete 删除并获取堆顶</div><div class="line">func (h *Heap) Delete() (top int, err error) &#123;</div><div class="line">	h.array, top, err = reset(h.array, h.isMax)</div><div class="line">	return top, err</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getCompareResult 比较</div><div class="line">func getCompareResult(o1, o2 int, isMax bool) int &#123;</div><div class="line">	if o1 == o2 &#123;</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	if isMax &#123;</div><div class="line">		if o1 &gt; o2 &#123;</div><div class="line">			return 1</div><div class="line">		&#125;</div><div class="line">		return -1</div><div class="line">	&#125;</div><div class="line">	if o1 &lt; o2 &#123;</div><div class="line">		return 1</div><div class="line">	&#125;</div><div class="line">	return -1</div><div class="line">&#125;</div><div class="line"></div><div class="line">//</div><div class="line">//</div><div class="line">// Insert 相关函数</div><div class="line">//</div><div class="line">//</div><div class="line"></div><div class="line">// insert 根据堆性质想数组中插入一个元素</div><div class="line">func insert(array []int, value int, isMax bool) (nowArray []int) &#123;</div><div class="line">	nowArray = append(array, 0)</div><div class="line">	insertIndex := getInsertIndex(nowArray, len(array), value, isMax)</div><div class="line">	nowArray[insertIndex] = value</div><div class="line">	return nowArray</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getInsertIndex 递归获取插入元素的数组下标</div><div class="line">// 使用上虑策略</div><div class="line">func getInsertIndex(array []int, nowIndex int, value int, isMax bool) int &#123;</div><div class="line">	if nowIndex &lt; 2 &#123;</div><div class="line">		return 1</div><div class="line">	&#125;</div><div class="line">	faIndex := getFaIndex(nowIndex)</div><div class="line">	if getCompareResult(array[faIndex], value, isMax) &gt;= 0 &#123;</div><div class="line">		return nowIndex</div><div class="line">	&#125;</div><div class="line">	array[faIndex], array[nowIndex] = array[nowIndex], array[faIndex]</div><div class="line">	return getInsertIndex(array, faIndex, value, isMax)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getFaIndex 获取一个元素的父级元素数组下标</div><div class="line">func getFaIndex(index int) int &#123;</div><div class="line">	return index / 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">//</div><div class="line">//</div><div class="line">// Delete 相关函数</div><div class="line">//</div><div class="line">//</div><div class="line"></div><div class="line">const (</div><div class="line">	noGo = iota</div><div class="line">	goLeft</div><div class="line">	goRight</div><div class="line">)</div><div class="line"></div><div class="line">// reset 重设置一个数组</div><div class="line">func reset(array []int, isMax bool) (nowArray []int, topValue int, err error) &#123;</div><div class="line">	lastIndex := len(array) - 1</div><div class="line">	if lastIndex == 1 &#123;</div><div class="line">		topValue = array[1]</div><div class="line">		nowArray = array[:lastIndex]</div><div class="line">		return</div><div class="line">	&#125; else if lastIndex &lt; 1 &#123;</div><div class="line">		return array, 0, fmt.Errorf(&quot;堆中已无元素&quot;)</div><div class="line">	&#125;</div><div class="line">	topValue, array[1] = array[1], 0</div><div class="line">	value := array[len(array)-1]</div><div class="line">	nowArray = array[:len(array)-1]</div><div class="line">	lastInsertIndex := getLastInsertIndex(nowArray, 1, value, isMax)</div><div class="line">	nowArray[lastInsertIndex] = value</div><div class="line">	return</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getLastInsertIndex 下虑</div><div class="line">func getLastInsertIndex(array []int, nowIndex int, value int, isMax bool) int &#123;</div><div class="line">	status := noGo</div><div class="line">	lastIndex := len(array) - 1</div><div class="line">	leftIndex, rightIndex := getSonIndex(nowIndex)</div><div class="line">	if lastIndex &gt;= rightIndex &#123;</div><div class="line">		left, right := array[leftIndex], array[rightIndex]</div><div class="line">		status = getStatus(left, right, value, isMax)</div><div class="line">	&#125; else if lastIndex == leftIndex &amp;&amp; getCompareResult(array[leftIndex], value, isMax) &gt;= 0 &#123;</div><div class="line">		status = goLeft</div><div class="line">	&#125;</div><div class="line">	switch status &#123;</div><div class="line">	case noGo:</div><div class="line">		return nowIndex</div><div class="line">	case goLeft:</div><div class="line">		array[nowIndex], array[leftIndex] = array[leftIndex], value</div><div class="line">		return getLastInsertIndex(array, leftIndex, value, isMax)</div><div class="line">	case goRight:</div><div class="line">		array[nowIndex], array[rightIndex] = array[rightIndex], value</div><div class="line">		return getLastInsertIndex(array, rightIndex, value, isMax)</div><div class="line">	&#125;</div><div class="line">	panic(&quot;--&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getSonIndex 获取一个元素的左右子元素数组下标</div><div class="line">func getSonIndex(index int) (left, right int) &#123;</div><div class="line">	return 2 * index, 2*index + 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getStatus 根据三个值获取走那边获取步鄹</div><div class="line">func getStatus(left, right, value int, isMax bool) (res int) &#123;</div><div class="line">	res = 0</div><div class="line">	if getCompareResult(left, value, isMax) &gt; 0 || getCompareResult(right, value, isMax) &gt; 0 &#123;</div><div class="line">		res++</div><div class="line">	&#125; else &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	if getCompareResult(right, left, isMax) &gt; 0 &#123;</div><div class="line">		res++</div><div class="line">	&#125;</div><div class="line">	return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/adt/head.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>插入时间复杂度：O(logN)</p>
<p>堆的实现确实惊为天人，如何的有魅力。<br>特别是上虑与下虑策略的思想，真是让人大开眼界。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;堆又称为优先队列，支持插入和删除堆顶操作；&lt;br&gt;分为最小堆、最大堆、还有一种扩展实现对顶堆，常用语实时获取中位数；&lt;br&gt;在贪婪算法的实现
    
    </summary>
    
      <category term="数据结构" scheme="http://fudali.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ADT" scheme="http://fudali.cc/tags/ADT/"/>
    
  </entry>
  
  <entry>
    <title>linux常用知识</title>
    <link href="http://fudali.cc/2017/03/20/linux/"/>
    <id>http://fudali.cc/2017/03/20/linux/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-20T09:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /var/log/messages</div></pre></td></tr></table></figure>
<h2 id="linux内存不足时kill进程策略"><a href="#linux内存不足时kill进程策略" class="headerlink" title="linux内存不足时kill进程策略"></a>linux内存不足时kill进程策略</h2><p>OOM_killer是Linux自我保护的方式，在内存不足时将被唤醒，调出<code>/proc/{pid}/oom_score</code>最大者并将之kill掉</p>
<p>为了保护重要进程不被OOM_killer kill掉，可以配置<code>/proc/{pid}/oom_score_adj</code>,此值为内核在为每个进行打分时的附加值，最后得分等于实际值+该值<br>顾可以使用<code>echo -20 &gt; /proc/{pid}/oom_score_adj</code>为实际值减去20(最后得分越小越不易被杀掉)</p>
<p>root进程默认获取-30的附加值<br><a href="http://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/" target="_blank" rel="external">详细来源，从源码的角度讲解</a><br><a href="https://github.com/torvalds/linux/blob/master/mm/oom_kill.c#L172-L222" target="_blank" rel="external">计算oom_score的函数linux源码</a></p>
<p>获取进程oom_score脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">for proc in $(find /proc -maxdepth 1 -regex &apos;/proc/[0-9]+&apos;); do</div><div class="line">    printf &quot;%2d %5d %s\n&quot; \</div><div class="line">        &quot;$(cat $proc/oom_score)&quot; \</div><div class="line">        &quot;$(basename $proc)&quot; \</div><div class="line">        &quot;$(cat $proc/cmdline | tr &apos;\0&apos; &apos; &apos; | head -c 50)&quot;</div><div class="line">done 2&gt;/dev/null | sort -nr | head -n 10</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内核日志&quot;&gt;&lt;a href=&quot;#内核日志&quot; class=&quot;headerlink&quot; title=&quot;内核日志&quot;&gt;&lt;/a&gt;内核日志&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="linux" scheme="http://fudali.cc/categories/linux/"/>
    
    
      <category term="linux" scheme="http://fudali.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://fudali.cc/2017/03/20/sort/"/>
    <id>http://fudali.cc/2017/03/20/sort/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-20T15:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h2><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p>
<p>堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。</p>
<h2 id="各算法时间复杂度与是否稳定"><a href="#各算法时间复杂度与是否稳定" class="headerlink" title="各算法时间复杂度与是否稳定"></a>各算法时间复杂度与是否稳定</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/sort.jpg" alt="各算法时间复杂度与是否稳定对照表" title="">
                </div>
                <div class="image-caption">各算法时间复杂度与是否稳定对照表</div>
            </figure>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://juejin.im/post/58ca051f61ff4b0060165122#数据结构" target="_blank" rel="external">掘金算法文章,包含各种算法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法稳定性&quot;&gt;&lt;a href=&quot;#排序算法稳定性&quot; class=&quot;headerlink&quot; title=&quot;排序算法稳定性&quot;&gt;&lt;/a&gt;排序算法稳定性&lt;/h2&gt;&lt;p&gt;假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序-快速排序</title>
    <link href="http://fudali.cc/2017/03/18/quick-sort/"/>
    <id>http://fudali.cc/2017/03/18/quick-sort/</id>
    <published>2017-03-17T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序是实践中一种快速的排序方式；他的平均运行时间是O(NlogN)，最坏运行时间是O(N^2)，但稍加努力可使最坏情形极难出现。<br>并且可通过与堆排序的结果，可以使几乎所有的输入都能达到快速排序的快速运行时间。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>快速排序可划分为简单的四个步骤(设输入数组为array)：</p>
<ul>
<li>如果array中元素是0或者1，直接返回</li>
<li>取array中任一元素pivot，称之为枢纽元(pivot)</li>
<li>将array中不包含pivot按与pivot的比较大小划分成连个不相交的集合</li>
<li>递归对划分的两个合集进行该四步走并获得返回值与pivot合并成返回数组</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">package quick</div><div class="line"></div><div class="line">// QuickSort 快速排序</div><div class="line">// 是否稳定?</div><div class="line">// 不稳定 可以试着分析下[5,1,2,2,3,4,5]</div><div class="line">func QuickSort(array []int) &#123;</div><div class="line">	quickSort(array, 0, len(array))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// quickSort 快速排序私有递归方法</div><div class="line">func quickSort(array []int, left, right int) &#123;</div><div class="line">	if right-left &lt; 2 &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	medianIndex := median3(array, left, right)</div><div class="line">	nowMedianIndex := swap(array, left, right, medianIndex)</div><div class="line">	quickSort(array, left, nowMedianIndex)</div><div class="line">	quickSort(array, nowMedianIndex+1, right)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// swap 按最开始的中位置下标将数组分为比中位置大和比中位值小的两个数组</div><div class="line">// left right 遵循右开左闭</div><div class="line">// return 划分后的中位值下标</div><div class="line">func swap(array []int, left, right, medianIndex int) (nowMedianIndex int) &#123;</div><div class="line">	median := array[medianIndex]</div><div class="line">	array[medianIndex], array[right-1] = array[right-1], median</div><div class="line">	leftPoint := left</div><div class="line">	rightPoint := right - 2</div><div class="line">	leftStop := false</div><div class="line">	rightStop := false</div><div class="line">	for &#123;</div><div class="line">		// 如果左滑动指针停止，不做任何操作，等待右滑动指针也停止交换</div><div class="line">		if !leftStop &#123;</div><div class="line">			if array[leftPoint] &lt;= median &#123;</div><div class="line">				leftPoint++</div><div class="line">			&#125; else &#123;</div><div class="line">				leftStop = true</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if !rightStop &#123;</div><div class="line">			if array[rightPoint] &gt;= median &#123;</div><div class="line">				rightPoint--</div><div class="line">			&#125; else &#123;</div><div class="line">				rightStop = true</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//当左滑动指针与右滑动指针相交后，左滑动指针位置一定处于大于等于中位值的位置</div><div class="line">		if leftPoint &gt; rightPoint &#123;</div><div class="line">			array[leftPoint], array[right-1] = array[right-1], array[leftPoint]</div><div class="line">			nowMedianIndex = leftPoint</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 如果都停止，交换位置并重启滑动</div><div class="line">		if leftStop &amp;&amp; rightStop &#123;</div><div class="line">			array[leftPoint], array[rightPoint] = array[rightPoint], array[leftPoint]</div><div class="line">			leftStop, rightStop = false, false</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// median3 三数中值分割法</div><div class="line">// 比较数组开头，结尾和中间位置的值，放回处于中间的值得数组下标</div><div class="line">// return 中位值数组下标</div><div class="line">func median3(array []int, left, right int) int &#123;</div><div class="line">	index := (right + left - 1) / 2</div><div class="line">	start := array[left]</div><div class="line">	median := array[index]</div><div class="line">	end := array[right-1]</div><div class="line">	if median &gt; start &#123;</div><div class="line">		if median &lt;= end &#123;</div><div class="line">			return index</div><div class="line">		&#125; else if end &gt;= start &#123;</div><div class="line">			return right - 1</div><div class="line">		&#125; else &#123;</div><div class="line">			return left</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		if median &gt;= end &#123;</div><div class="line">			return index</div><div class="line">		&#125; else if start &gt;= end &#123;</div><div class="line">			return right - 1</div><div class="line">		&#125; else &#123;</div><div class="line">			return left</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/quick/quick.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>平均运行时间：O(NlogN)<br>最坏运行时间：O(N^2)<br>是否稳定：不稳定，试着分析[5,1,2,2,3,4,5]即可找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">选取枢纽元为2，是枢纽元到数组末尾</div><div class="line">5   1   2   5   3   4   2</div><div class="line">i                   j</div><div class="line"></div><div class="line">进行第一次交换的地方</div><div class="line">5   1   2   5   3   4   2</div><div class="line">i   j</div><div class="line"></div><div class="line">第一次交换过后</div><div class="line">1   5   2   5   3   4   2</div><div class="line">j   i</div><div class="line"></div><div class="line">此时 i &gt; j 将枢纽元从末尾与i位置元素调换</div><div class="line">1   2   2   5   3   4   5</div><div class="line"></div><div class="line">此时作为枢纽元的2从最开始的index=3变成了index=1</div><div class="line">跑到了与之相等的index为2的元素的前面，值为5的元素也发生了相似的状况</div><div class="line">顾快速排序为不稳定的排序</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序是实践中一种快速的排序方式；他的平均运行时间是O(NlogN)，最坏运行时间是O(N^2)，但稍加努力可使最坏情形极难出现。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>tcp和udp网络协议</title>
    <link href="http://fudali.cc/2017/03/17/tcp-and-udp-protocols/"/>
    <id>http://fudali.cc/2017/03/17/tcp-and-udp-protocols/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-18T04:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。<br>在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，UDP是无连接的协议。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><ul>
<li>是传输层的一种面向连接的协议</li>
<li>处理下层的不可靠数据使之变得可靠(确定通过网络发送的数据报的状态并且如果部分已被丢弃则处理信息的重发的任务并按正确的顺序重新组合成消息以提供可靠性)</li>
<li>TCP驻留在传输层中，并仅驻留在实际处理数据报的机器上，确保数据报已从源机器到目标机器；它不驻留在简单路由数据报的设备上，因此网关中没有TCP层。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/4/40/Fig1_net_tcp.jpg" alt="tcp协议留驻在传输层示意图" title="">
                </div>
                <div class="image-caption">tcp协议留驻在传输层示意图</div>
            </figure>
</li>
</ul>
<h3 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h3><ul>
<li><p>单播协议:<br>TCP基于单播网络模型，支持两方之间的数据交换。它不支持广播或多播网络模型。</p>
</li>
<li><p>连接状态:<br>TCP使用两个端点之间的同步状态，而不是在网络内强加一个状态来支持连接。<br>该同步状态被设置为初始连接过程的一部分，因此TCP可以被认为是面向连接的协议。<br>许多协议设计旨在确保每个本地状态转换被传送到远程方并由其确认。</p>
</li>
<li><p>可靠性:</p>
<p>可靠性意味着在连接的一端传递给TCP驱动程序的八位字节流将通过网络传输，使得流作为相同的八位字节序列呈现给远程进程，顺序与生成的由发送方。这意味着协议检测数据流的分段何时已被网络丢弃，重新排序，复制或损坏。<br>在必要的情况下，发送器将重传损坏的段，以便允许接收器重建原始数据流。<br>这意味着TCP发送方必须保持所有发送数据的本地副本，直到它接收到接收方已经完成数据的准确传送的指示为止。</p>
</li>
<li><p>全双工:</p>
<p>TCP是全双工协议; 它允许双方在单个TCP连接的上下文内发送和接收数据。</p>
</li>
<li><p>流:</p>
<p>虽然TCP使用分组结构用于网络传输，但TCP是真正的流传输协议，并且应用级网络操作不透明。一些协议明确地封装每个应用事务;<br>对于每一次写，都必须有一个匹配的读。以这种方式，在网络上保留数据流到逻辑记录结构的应用派生分段。<br>TCP不保留施加在数据流上的这种隐式结构，使得在网络协议内的写和读操作之间不存在配对。<br>例如，TCP应用可以将三个数据块按顺序写入网络连接，其可以由远程读取器在单个读取操作中收集。TCP会话中使用的数据块（段）的大小在会话开始时协商。<br>发送器尝试在接收器的最大段大小，配置的发送器的最大段大小和最大可支持的非分段分组大小的限制内使用它可以用于数据传输的最大段大小网络路径（路径最大传输单元[MTU]）。<br>路径MTU周期性地刷新以适应在TCP连接活动时可能发生在网络内的任何改变。</p>
</li>
<li><p>速率适配:</p>
<p>TCP也是速率自适应协议，因为数据传输速率旨在适应网络内的主要负载条件并适应接收机的处理能力。<br>没有预定的TCP数据传输速率; 如果网络和接收器都具有额外的可用容量，则TCP发送器将尝试向网络注入更多数据以占用此可用空间。<br>相反，如果有拥塞，TCP发送方将降低其发送速率以允许网络恢复。该适配功能试图实现最高可能的数据传输速率，而不触发一致的数据丢失。</p>
</li>
</ul>
<h3 id="TCP建立连接三次握手"><a href="#TCP建立连接三次握手" class="headerlink" title="TCP建立连接三次握手"></a>TCP建立连接三次握手</h3><p>客户端发送SYN消息; 服务器发送组合对客户端的SYN的ACK并且包含服务器的SYN的消息; 然后客户端发送对服务器的SYN的ACK。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/4/46/New_tcp_action1.JPG" alt="建立连接步鄹图" title="">
                </div>
                <div class="image-caption">建立连接步鄹图</div>
            </figure></p>
<p>连接在其生命周期中经过一系列状态:</p>
<p>  侦听，SYN发送，SYN接收，建立，FIN-WAIT-1，FIN-WAIT-2，CLOSE-等待，CLOSING，LAST-ACK，TIME-WAIT和虚构状态CLOSED。CLOSED是虚构的，因为它代表没有TCP时的状态，因此没有连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">LISTEN - 表示等待来自任何远程TCP和端口的连接请求。</div><div class="line"></div><div class="line">SYN-SENT - 表示在发送连接请求之后等待匹配的连接请求。</div><div class="line"></div><div class="line">SYN-RECEIVED - 表示在接收和发送连接请求之后等待确认连接请求确认。</div><div class="line"></div><div class="line">ESTABLISHED - 表示打开连接，收到的数据可以传递给用户。连接的数据传输阶段的正常状态。</div><div class="line"></div><div class="line">FIN-WAIT-1表示等待来自远程TCP的连接终止请求，或者先前发送的连接终止请求的确认。</div><div class="line"></div><div class="line">FIN-WAIT-2 - 表示等待来自远程TCP的连接终止请求。</div><div class="line"></div><div class="line">CLOSE-WAIT - 表示等待来自本地用户的连接终止请求。</div><div class="line"></div><div class="line">CLOSING - 表示等待来自远程TCP的连接终止请求确认。</div><div class="line"></div><div class="line">LAST-ACK-表示等待先前发送到远程TCP的连接终止请求的确认（其包括对其连接终止请求的确认）。</div><div class="line"></div><div class="line">TIME-WAIT - 表示等待足够的时间通过，以确保远程TCP接收到其连接终止请求的确认。</div><div class="line"></div><div class="line">CLOSED - 根本不表示连接状态。</div></pre></td></tr></table></figure></p>
<p>  TCP连接响应事件从一个状态进行到另一个状态。事件是用户调用，OPEN，SEND，RECEIVE，CLOSE，ABORT和STATUS; 传入段，特别是包含SYN，ACK，RST和FIN标志的段; 和超时。</p>
<h3 id="连接建立和终止"><a href="#连接建立和终止" class="headerlink" title="连接建立和终止"></a>连接建立和终止</h3><ul>
<li><p>建立连接</p>
<p>只有在两个机器之间的连接不存在，两个机器都同意连接，并且两个机器都有足够的TCP资源来为连接提供服务时，才能在两台机器之间建立连接。<br>如果不满足这些条件中的任何一个，则不能进行连接。连接的接受可以由应用或系统管理例程触发。</p>
</li>
<li><p>数据传输</p>
<p>对于由机器A的TCP从ULP接收的每个数据块，TCP封装它并且以递增的序列号将其发送到机器B. 在机器B接收到消息之后，它使用增加下一个序列号的分段确认来确认它（并且因此指示它接收到该序列号的一切）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/d/d7/Ntwk_data_trans.JPG" alt="tcp传输图" title="">
                </div>
                <div class="image-caption">tcp传输图</div>
            </figure>
<p>TCP数据传输服务实际上体现了六个不同的子服务：</p>
<ul>
<li><p>全双工：使连接的两端在任何时间，甚至同时发送。</p>
</li>
<li><p>及时性：使用计时器可确保在合理的时间内传输数据。</p>
</li>
<li><p>有序：从一个应用程序发送的数据将在另一端以相同的顺序接收。这发生，尽管事实上数据报可能通过IP被无序地接收，因为TCP在将消息传递到较高层之前以正确的顺序重新组装消息。</p>
</li>
<li><p>标签：所有连接具有商定的优先级和安全值。</p>
</li>
<li><p>受控流：TCP可以通过使用缓冲区和窗口限制来调节信息流。</p>
</li>
<li><p>错误校正：校验和确保数据没有错误（在校验和算法的限制内）。</p>
</li>
</ul>
</li>
<li><p>关闭连接<br>为了关闭连接，TCP之一从ULP接收关闭原语并发出具有设置为开的FIN标志的消息。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/c/c4/Ntwk_conn_close.JPG" alt="tcp关闭连接示意图" title="">
                </div>
                <div class="image-caption">tcp关闭连接示意图</div>
            </figure>
<p>在图中，机器A的TCP发送请求以关闭具有下一个序列号的机器B的连接。机器B然后将发送对该请求及其下一个序列号的确认。随后，机器B通过其ULP将关闭消息发送到应用程序，并等待应用程序确认关闭。这一步不是绝对必要的; TCP可以在没有应用程序批准的情况下关闭连接，但是一个良好的系统会通知应用程序状态的改变</p>
</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="什么是UDP"><a href="#什么是UDP" class="headerlink" title="什么是UDP"></a>什么是UDP</h3><p> UDP是无连接和不可靠的传输协议。两个端口用于标识源和目标机器内的端点。当不需要可靠的传递时，使用用户数据报协议来代替TCP。然而，UDP从不用于发送诸如网页，数据库信息等重要数据。流式媒体例如视频，音频和其他使用UDP因为它提供速度。</p>
<h3 id="UDP的特性"><a href="#UDP的特性" class="headerlink" title="UDP的特性"></a>UDP的特性</h3><ul>
<li><p>端到端。UDP可以识别在计算机上运行的特定进程。</p>
</li>
<li><p>不可靠，无连接传递（例如USPS:UDP使用无连接通信设置。在这个UDP中不需要在发送数据之前建立连接。通信仅由数据段本身组成）。</p>
</li>
<li><p>与IP相同的尽力语义</p>
</li>
<li><p>无ack，无序列，无流量控制</p>
</li>
<li><p>丢失，复制，延迟，无序或丢失连接</p>
</li>
<li><p>快速，低开销</p>
<p>因为以上特性udp更适合:</p>
<ul>
<li>适合可靠的本地网络</li>
<li>RTP（实时传输协议</li>
</ul>
</li>
</ul>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>UDP是传输层协议。UDP是一种无连接和不可靠的协议。UDP不做流量控制，错误控制或重传坏段。UDP比TCP快。UDP通常用于流音频和视频。UDP从未用于重要的文档，如网页，数据库信息等。UDP传输由8字节头组成的段。它包含源端口，目标端口，UDP长度和校验和。UDP校验和用于检测传输段中的“错误”。</p>
<h2 id="TCP-VS-UDP"><a href="#TCP-VS-UDP" class="headerlink" title="TCP VS UDP"></a>TCP VS UDP</h2><p> 用户数据报协议（UDP）和传输控制协议（TCP）是TCP / IP协议组中传输层的“同级”。它们执行相同的角色，提供应用程序和Internet协议（IP）的数据移动功能之间的接口，但是它们以非常不同的方式实现。因此，这两种协议为高层协议提供了选择，允许每个协议根据其需要选择适当的协议。</p>
<p> 有助于说明这两种协议的最重要的基本属性以及它们如何彼此对比的表：<br> <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/5/55/Tcp%26udp.jpg" alt="tcp&udp比较图" title="">
                </div>
                <div class="image-caption">tcp&udp比较图</div>
            </figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。&lt;br&gt;在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，
    
    </summary>
    
      <category term="网络协议" scheme="http://fudali.cc/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="网络" scheme="http://fudali.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="tcp/ip" scheme="http://fudali.cc/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>排序-归并排序</title>
    <link href="http://fudali.cc/2017/03/17/merge-sort/"/>
    <id>http://fudali.cc/2017/03/17/merge-sort/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>归并排序体现了递归分治的策略<br>思想是将数组拆分为两段，在对两段进行想通操作，直到数组元素为1，在对数组进行排序合并</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package merge</div><div class="line"></div><div class="line">// MergeSort 归并排序</div><div class="line">func MergeSort(array []int) []int &#123;</div><div class="line">	middle := len(array) / 2</div><div class="line">	if middle &lt; 1 &#123;</div><div class="line">		return array</div><div class="line">	&#125;</div><div class="line">	return merge(MergeSort(array[:middle]), MergeSort(array[middle:]))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// merge 合并两个排好序的数组唯一组合两个元素并排好序的数组</div><div class="line">func merge(a1 []int, a2 []int) []int &#123;</div><div class="line">	a1Index := 0</div><div class="line">	a2Index := 0</div><div class="line">	res := make([]int, 0, len(a1)+len(a2))</div><div class="line">	for &#123;</div><div class="line">		if a1[a1Index] &lt;= a2[a2Index] &#123;</div><div class="line">			res = append(res, a1[a1Index])</div><div class="line">			if a1Index == len(a1)-1 &#123;</div><div class="line">				res = append(res, a2[a2Index:]...)</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">			a1Index++</div><div class="line">		&#125; else &#123;</div><div class="line">			res = append(res, a2[a2Index])</div><div class="line">			if a2Index == len(a1)-1 &#123;</div><div class="line">				res = append(res, a1[a1Index:]...)</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">			a2Index++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return res</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/merge/merge.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然归并排序的运行时间是O(NlogN)，但是他合并两个已排序数组到一个附加数组会更占用内存。</p>
<p>与其他O(NlogN)的流行算法相比，归并排序是比较元素最少的，且运行时间严重依赖于比较元素和在数组(已经临时数组)中移动元素的开销(理论上使用更少内存的算法是可能的，但所得到的算法是复杂的和不实际的)。</p>
<p>这些开销是于语言相关的(java中泛型数组中的元素是引用类型的，顾移动元素开销不大，所以归并排序是java泛型数组的默认排序方式。</p>
<p>快速排序作为基础类型的排序方式，java基础类型是值传递的，因为比较与数据移动的开销是类似的，快排使用少得多的数据移动足以补偿那些附加的比较而且还有盈余)。</p>
<p>在go中也存在相同的问题，所以在不同的输入数据选择不同的排序方式再能得到最好的性能。</p>
<p>平均运行时间：O(NlogN)<br>最坏运行时间：O(NlogN)<br>是否稳定：稳定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;归并排序体现了递归分治的策略&lt;br&gt;思想是将数组拆分为两段，在对两段进行想通操作，直到数组元素为1，在对数组进行排序合并&lt;/p&gt;
&lt;h2 i
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序-希尔排序</title>
    <link href="http://fudali.cc/2017/03/15/shell-sort/"/>
    <id>http://fudali.cc/2017/03/15/shell-sort/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>个人认为希尔排序是对插入排序的一种优化，<br>他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序)。<br>所以希尔排序也称为缩减增量排序<br>他相比插入排序所在的优势是，他可以一次交换两个较远距离的元素，而插入排序交换两个相聚n的元素位子需要n次交换。</p>
<p>因为他根据一个算法来决定每趟比较的距离，所以该算法的好坏也会在一定程度上决定希尔排序的性能</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 利用每次除以2的等比增量数列来决定每趟比较距离</div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	arrayLen := len(array)</div><div class="line">	for gap := arrayLen / 2; gap &gt; 0; gap /= 2 &#123;</div><div class="line">		for i := gap; i &lt; arrayLen; i++ &#123;</div><div class="line">			iv := array[i]</div><div class="line">			for j := i; j-gap &gt; 0 &amp;&amp; array[j-gap] &gt; iv; j -= gap &#123;</div><div class="line">				n++</div><div class="line">				array[j-gap], array[j] = iv, array[j-gap]</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;---------------&quot;, n)</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/shell/shell.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希尔排序的性能在实践中的性能是完全可以接受的；<br>使用希尔增量是最坏情形运行时间复杂度为O(N^2)<br>对于好的增量序列，最坏时间复杂度还可以优化</p>
<p>编程的简单特点，使它成为对适度的大量输入数据进行排序的常用算法</p>
<p>最优运行时间：O(N)<br>最坏运行时间：O(N^2)<br>是否稳定：不稳定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;个人认为希尔排序是对插入排序的一种优化，&lt;br&gt;他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序-插入排序</title>
    <link href="http://fudali.cc/2017/03/13/insertion-sort/"/>
    <id>http://fudali.cc/2017/03/13/insertion-sort/</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  -<br>  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模式方面的知识<br>  -<br>  今天就想来理解一下排序算法中最简单的插入排序：<br>  插入排序思路为顺序遍历数组，并在遍历中从顺序遍历到的元素倒序遍历回<br>  倒序遍历是判断相邻两个元素是否符合排序规则<br>  如果符合则停止倒序遍历<br>  如果不符合则交换相邻两个元素位置并继续倒序遍历</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ppackage main</div><div class="line"></div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	// 从1开始遍历,因为0前面没有数值</div><div class="line">	for i := 1; i &lt; len(array); i++ &#123;</div><div class="line">		// 在此处放置与在 代码1 处放置效果一样</div><div class="line">		// 因为若 jv &gt; iv 的话 ， j 与 j-1 调换位置， 下一次循环时 array[j] 依然是当初的 iv</div><div class="line">		iv := array[i]</div><div class="line">		for j := i; j &gt;= 0 &amp;&amp; array[j-1] &gt;= iv; j-- &#123;</div><div class="line">			// 代码1  iv := array[j]</div><div class="line"></div><div class="line">			// 如果 jv &gt; iv , 调换两个元素之间的位置</div><div class="line">			n++</div><div class="line">			array[j], array[j-1] = array[j-1], iv</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;----------------&quot;, n)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/insertion.go" target="_blank" rel="external">golang code on github</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Insertion &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Integer[] oo = new Integer[]&#123;34, 8, 64, 51, 32, 21&#125;;</div><div class="line">	    sort(oo);</div><div class="line">        for (Integer var : oo) &#123;</div><div class="line">            System.out.println(var);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; void sort(T[] array) &#123;</div><div class="line">        for (int i = 1; i&lt; array.length; i++) &#123;</div><div class="line">            T it = array[i];</div><div class="line">            for (int j = i; j &gt; 0; j--) &#123;</div><div class="line">                T jt = array[j - 1];</div><div class="line">                if (compare(jt, it) &lt; 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;else &#123;</div><div class="line">                    array[j] = jt;</div><div class="line">                    array[j - 1] = it;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; int compare(T o1, T o2) &#123;</div><div class="line">        return (Integer)o1 - (Integer)o2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/Insertion.java" target="_blank" rel="external">java code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从原理和显示方式可以看出，当数组本就按排序规则排好序时，时间复杂度最小为 O(N)；当数组为倒序时未最坏情况，测试时间复杂度为O(N^2)<br>当数组中根据排序规则倒序的元素对越多，时间复杂度越大，当数组根据排序规则完全倒序时，时间复杂度最大为 2+3+4+…+N = O(N)</p>
<p>平均运行时间：O(NlogN)<br>最坏运行时间：O(NlogN)<br>是否稳定：稳定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  -&lt;br&gt;  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>go 1.6.2 strings split 方法改造</title>
    <link href="http://fudali.cc/2016/12/13/go1.6.2-strings-split/"/>
    <id>http://fudali.cc/2016/12/13/go1.6.2-strings-split/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2017-03-18T04:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>当调用<code>strings.Split(s,seq string)</code>时,如果seq连续出现，比如<code>s=&quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk      &quot;</code>。调用<code>slice:=strings.Split(s,&quot; &quot;)</code>将会出现<code>len(slice)!=3</code>，我认为这并不是大家希望看到的结果。</p>
<p>查看<code>strings.Split(s,seq string)</code>源码：<br><code>func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }</code></p>
<p>接着查看<code>strings.genSplit()</code>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func genSplit(s, sep string, sepSave, n int) []string &#123;</div><div class="line">	if n == 0 &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	if sep == &quot;&quot; &#123;</div><div class="line">		return explode(s, n)</div><div class="line">	&#125;</div><div class="line">	if n &lt; 0 &#123;</div><div class="line">		n = Count(s, sep) + 1</div><div class="line">	&#125;</div><div class="line">	c := sep[0]</div><div class="line">	start := 0</div><div class="line">	a := make([]string, n)</div><div class="line">	na := 0</div><div class="line">	for i := 0; i+len(sep) &lt;= len(s) &amp;&amp; na+1 &lt; n; i++ &#123;</div><div class="line">		if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			a[na] = s[start : i+sepSave]</div><div class="line">			na++</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	a[na] = s[start:]</div><div class="line">	return a[0 : na+1]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发现并没有做相关的判断就将<code>s[start : i+sepSave]</code>添加到返回数组造成出现这种情况；</p>
<p>顾在for循环中添加一个判断以达到预期返回值，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			splitStr:=s[start : i+sepSave]</div><div class="line">			if !(splitStr == sep || start==i+sepSave) &#123;</div><div class="line">				a[na] = splitStr</div><div class="line">				na++</div><div class="line">			&#125;</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后调用即可达到预期返回值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当调用&lt;code&gt;strings.Split(s,seq string)&lt;/code&gt;时,如果seq连续出现，比如&lt;code&gt;s=&amp;quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk    
    
    </summary>
    
      <category term="golang笔记" scheme="http://fudali.cc/categories/golang%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>beego upsert 方法原理</title>
    <link href="http://fudali.cc/2016/12/13/beego-upsert-method/"/>
    <id>http://fudali.cc/2016/12/13/beego-upsert-method/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2017-03-18T04:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂只支持mysql与postgres。实现原理是数据自带可实现insertorupdate的功能语句。<br>mysql：<strong><code>ON DUPLICATE KEY UPDATE</code></strong><br>postgres : <strong><code>ON CONFLICT DO UPDATE SET</code></strong><br>然后去orm实现中自己拼装sql语句</li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><ul>
<li>好了，亮代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">func (d *dbBase) InsertOrUpdate(q dbQuerier, mi *modelInfo,ind reflect.Value, tz *time.Location, dn string, args ...string) (int64, error) &#123;</div><div class="line"></div><div class="line">	iouStr := &quot;&quot;</div><div class="line">	mysql := &quot;mysql&quot;</div><div class="line">	postgres := &quot;postgres&quot;</div><div class="line">	argsMap := map[string]string&#123;&#125;</div><div class="line"></div><div class="line">	if dn == mysql &#123;</div><div class="line">		iouStr = &quot;ON DUPLICATE KEY UPDATE&quot;</div><div class="line">	&#125; else if dn == postgres &amp;&amp; len(args) &gt; 0 &#123;</div><div class="line">		args0 = args[0]</div><div class="line">		iouStr = fmt.Sprintf(&quot;ON CONFLICT (%s) DO UPDATE SET&quot;, args0)</div><div class="line">	&#125; else &#123;</div><div class="line">		return 0, fmt.Errorf(&quot;`%s` nonsupport insert or update in beego&quot;, dn)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for _, v := range args &#123;</div><div class="line">		kv := strings.Split(v, &quot;=&quot;)</div><div class="line">		if len(kv) == 2 &#123;</div><div class="line">			argsMap[kv[0]] = kv[1]</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	isMulti := false</div><div class="line">	names := make([]string, 0, len(mi.fields.dbcols)-1)</div><div class="line">	Q := d.ins.TableQuote()</div><div class="line">	values, err := d.collectValues(mi, ind, mi.fields.dbcols, true, true, &amp;names, tz)</div><div class="line">	if err != nil &#123;</div><div class="line">		return 0, err</div><div class="line"></div><div class="line">	marks := make([]string, len(names))</div><div class="line">	updateValues := make([]interface&#123;&#125;, 0)</div><div class="line">	updates := make([]string, len(names))</div><div class="line">	var conflitValue interface&#123;&#125;</div><div class="line">	for i, v := range names &#123;</div><div class="line">		marks[i] = &quot;?&quot;</div><div class="line">		valueStr := argsMap[v]</div><div class="line">		if v == args0 &#123;</div><div class="line">			conflitValue = values[i]</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if valueStr != &quot;&quot; &#123;</div><div class="line">			switch dn &#123;</div><div class="line">			case mysql:</div><div class="line">				updates[i] = v + &quot;=&quot; + valueStr</div><div class="line">				break</div><div class="line">			case postgres:</div><div class="line">				if conflitValue != nil &#123;</div><div class="line">			updates[i] = fmt.Sprintf(&quot;%s=(select %s from %s where %s = ? )&quot;, v, valueStr, mi.table, args[0])</div><div class="line">					updateValues = append(updateValues, conflitValue)</div><div class="line">				&#125; else &#123;</div><div class="line">					return 0, fmt.Errorf(&quot;`%s` must be in front of `%s` in your struct&quot;, args[0], v)</div><div class="line">				&#125;</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			updates[i] = v + &quot;=?&quot;</div><div class="line">			updateValues = append(updateValues, values[i])</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	values = append(values, updateValues...)</div><div class="line">	sep := fmt.Sprintf(&quot;%s, %s&quot;, Q, Q)</div><div class="line">	qmarks := strings.Join(marks, &quot;, &quot;)</div><div class="line">	qupdates := strings.Join(updates, &quot;, &quot;)</div><div class="line">	columns := strings.Join(names, sep)</div><div class="line">	multi := len(values) / len(names)</div><div class="line"></div><div class="line">	if isMulti &#123;</div><div class="line">		qmarks = strings.Repeat(qmarks+&quot;), (&quot;, multi-1) + qmarks</div><div class="line">	&#125;</div><div class="line">	query := fmt.Sprintf(&quot;INSERT INTO %s%s%s (%s%s%s) VALUES (%s) %s &quot;+qupdates, Q, mi.table, Q, Q, columns, Q, qmarks, iouStr)</div><div class="line"></div><div class="line">	if isMulti || !d.ins.HasReturningID(mi, &amp;query) &#123;</div><div class="line">		res, err := q.Exec(query, values...)</div><div class="line">		if err == nil &#123;</div><div class="line">			if isMulti &#123;</div><div class="line">				return res.RowsAffected()</div><div class="line">			&#125;</div><div class="line">			return res.LastInsertId()</div><div class="line">		&#125;</div><div class="line">		return 0, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	row := q.QueryRow(query, values...)</div><div class="line">	var id int64</div><div class="line">	err = row.Scan(&amp;id)</div><div class="line">	return id, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>这就是实现功能的全部逻辑，当然要想在beego orm中使用insertorupdate还有一些其他的工作要做，首先这段代码应该添加在 <strong><code>beego/orm文件夹下的db.go文件中</code></strong></p>
</li>
<li><p>然后在 <strong><code>orm.go</code></strong> 文件中添加</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> func (o *orm) InsertOrUpdate(md interface&#123;&#125;,colConflitAndArgs ...string) (int64, error) &#123;</div><div class="line"></div><div class="line">	mi, ind := o.getMiInd(md, true)</div><div class="line">	id, err := o.alias.DbBaser.InsertOrUpdate(o.db, mi, ind, o.alias.TZ, o.alias.DriverName, colConflitAndArgs...)</div><div class="line">	if err != nil &#123;</div><div class="line">		return id, err</div><div class="line">		&#125;</div><div class="line">	o.setPk(mi, ind, id)</div><div class="line">	return id, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">再在types.go文件中的type Ormer interface和type dbBaser interface中分别添加</div><div class="line">InsertOrUpdate(md interface&#123;&#125;, colConflitAndArgs ...string) (int64, error) 与</div><div class="line">InsertOrUpdate(dbQuerier, *modelInfo, reflect.Value, *time.Location, string, ...string) (int64, error)</div></pre></td></tr></table></figure>
<ul>
<li>好了，现在大功告成了。可以使用InssertOrUpdate功能了<br>列如：</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql：</div><div class="line"></div><div class="line">func IOUFinish(all *Finish) int64 &#123;</div><div class="line"></div><div class="line">	db := orm.NewOrm()</div><div class="line">	db.Using(&quot;mysql&quot;)</div><div class="line">	r, e := db.InsertOrUpdate(all, &quot;step=step+1&quot;)</div><div class="line">	if e != nil &#123;</div><div class="line">		fmt.Println(e)</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	fmt.Println(r)</div><div class="line">	return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个函数在出入数据时有主键或者唯一键冲突，将执行update操作，其中step列执行+自增操作，其他列按model中的值进行update操作。其中”step=step+1”格式数据可以有多个也可以没有，这种格式只用于自增操作</li>
</ul>
<h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">postgres：</div><div class="line"></div><div class="line">func IOUFinish(all *Finish) int64 &#123;</div><div class="line"></div><div class="line">	db := orm.NewOrm()</div><div class="line">	db.Using(&quot;postgres&quot;)</div><div class="line">	r, e := db.InsertOrUpdate(all,&quot;confilctColumnName&quot; &quot;step=step+1&quot;)</div><div class="line">	if e != nil &#123;</div><div class="line">		fmt.Println(e)</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	fmt.Println(r)</div><div class="line">	return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当操作postgres数据库是，必须在model后的第一个参数指定你预期的冲突列的列名(由于实现此功能的sql语句需要且数据库版本必须大于9.5，因为实现的语句由9.5版本推出)，其他与mysql一致。</li>
</ul>
<p>提示：在使用自增操作是最好不要自增主键或者唯一键，可能会引起错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂
    
    </summary>
    
      <category term="开源项目" scheme="http://fudali.cc/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="beego" scheme="http://fudali.cc/tags/beego/"/>
    
  </entry>
  
  <entry>
    <title>ELK学习之安装logstash</title>
    <link href="http://fudali.cc/2016/02/16/ELK-install-logstash/"/>
    <id>http://fudali.cc/2016/02/16/ELK-install-logstash/</id>
    <published>2016-02-15T16:00:00.000Z</published>
    <updated>2017-03-18T05:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ul>
<li>logstash基于jvm平台，所以安装前确认已安装jre</li>
<li>最新的logstash 5.*版本至少需要java8以上jre</li>
<li>对于Debian平台或者Redhat平台,官方推荐配置软件仓库并安装</li>
</ul>
<h3 id="Debian-Ubuntu-平台"><a href="#Debian-Ubuntu-平台" class="headerlink" title="Debian/Ubuntu 平台"></a>Debian/Ubuntu 平台</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | apt-key add -</div><div class="line">cat &gt;&gt; /etc/apt/sources.list &lt;&lt;EOF</div><div class="line">deb http://packages.elasticsearch.org/logstash/5.0/debian stable main</div><div class="line">EOF</div><div class="line">apt-get update</div><div class="line">apt-get install logstash</div></pre></td></tr></table></figure>
<p>一行一行复制输入命令行即可</p>
<p>有可能出现如下错误(也有可能是运行时出现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Could not find any executable java binary. Please install java in your PATH or set JAVA_HOME.</div></pre></td></tr></table></figure></p>
<p>此时需要修改logstash的启动配置文件，对Debian/Ubuntu系统，该文件路径为<code>/etc/logstash/startup.options</code>，其中的JAVACMD参数默认为<code>/usr/**</code>,顾导致找不到java命令，只需将改参数改为你的<code>$JAVA_HOME/bin/java</code>即可解决该错误</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>软件仓库安装后logstash bin所在路径为<code>/usr/share/logstash</code></p>
<p>直接运行简单命令行输入input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -e &apos;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>配置文件运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -f &#123;配置文件路径&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;logstash基于jvm平台，所以安装前确认已安装jre&lt;/li&gt;
&lt;li&gt;最新的logstash 5.*版本
    
    </summary>
    
      <category term="日志收集" scheme="http://fudali.cc/categories/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="ELK" scheme="http://fudali.cc/tags/ELK/"/>
    
      <category term="logstash" scheme="http://fudali.cc/tags/logstash/"/>
    
  </entry>
  
</feed>
