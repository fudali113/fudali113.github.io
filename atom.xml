<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fudali</title>
  <subtitle>do one`s best</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fudali.cc/"/>
  <updated>2017-12-28T03:20:42.065Z</updated>
  <id>http://fudali.cc/</id>
  
  <author>
    <name>fudali</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Service Mesh</title>
    <link href="http://fudali.cc/2017/12/28/service-mesh-first/"/>
    <id>http://fudali.cc/2017/12/28/service-mesh-first/</id>
    <published>2017-12-27T16:00:00.000Z</published>
    <updated>2017-12-28T03:20:42.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://www.servicemesh.cn/?/article/21" target="_blank" rel="external">Service Mesh的诞生</a></p>
<p>软件应用从来都是遵循高内聚低耦合的原则；从互联网刚诞生时的七层网络协议栈的定义，到今天service mesh的诞生；对于微服务，我们更加希望我们的服务实体能够更加的专注于业务逻辑的实现，其他的事我们应该交给更专业的工具去做；</p>
<h2 id="格局"><a href="#格局" class="headerlink" title="格局"></a>格局</h2><p> <a href="http://www.servicemesh.cn/?/article/25" target="_blank" rel="external">Service Mesh 时代的选边与站队</a></p>
<p> 目前成熟的已经在生产环境进过验证的有Bouyant(最早提出service mesh概念，由twitter两位工程师创建)公司的<a href="https://github.com/linkerd/linkerd" target="_blank" rel="external">linkerd</a>与lyft的<a href="https://github.com/envoyproxy/envoy" target="_blank" rel="external">envoy</a>,但是目前该两个相对于与kubernets的集成方面需要依赖于 <a href="https://github.com/istio/istio" target="_blank" rel="external">istio</a>(由google，IBM，lyft成立相关研发组研发) 项目(istio由数据平面和控制平面组成，前面提到的两位在istio中都相当于充当着数据平面的位置，由于istio提供灵活的建构，<a href="http://www.servicemesh.cn/?/article/24" target="_blank" rel="external">数据平面与控制平面</a>是通过特定api进行交流的，顾数据平面对istio项目是可以替换的)；由于istio的推出，且Bouyant公司就是为service mesh而生，自己必须要在这个领域占有发言权，顾推出了<a href="https://github.com/runconduit/conduit" target="_blank" rel="external">conduit</a>与istio竞争争取在该领域获取发言权。</p>
<ul>
<li>istio 目前0.4版本，还不能在生成环境使用</li>
<li>conduit 17年12月发布0.1，也还不能在生成环境使用</li>
</ul>
<h2 id="对于我们"><a href="#对于我们" class="headerlink" title="对于我们"></a>对于我们</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>由于我们使用了spring cloud技术栈来构建我们的微服务，对于我们的对比其实就是spring cloud 提供的sdk集成方式 与 service mesh 提供的基础设施与具体业务分离的对比。</p>
<p>对于之前我们的分析，其实可以发现，互联网的发展，最开始的时候都是我们在应用之中做很多的事情让我们的引用支持各种功能来实现我们的业务；最后随着技术的成熟，基础的设施与技术与实际业务独立开来，制定相关的协议和应用相关的工具来实现一样的功能。</p>
<p>由此我们可以看出，service mesh才应该是微服务的最终形态。</p>
<h3 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h3><ul>
<li>因为service mesh的前提是我们最好能够在kubernets里面运行我们的应用，所以需要有kubernets平台</li>
<li>对于我们应用集成的spring cloud 相关的组件，我们只需要删除相关的依赖，有service mesh去管理我们服务间的调用，我们连我们之前的feign api都是可以复用；所以，我们在平台完整的情况下，迁移的成本非常低</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>底层基础设施与业务代码解耦，降低我们开发应用的复杂性，我们可以使用更适合的语言更适合的框架来构建我们应用而不用去管理那一坨复杂的spring cloud依赖</li>
<li>service mesh还可以给我们带来与应用解耦的流量控制，访问控制，转发策略(结合kunernets在做发布策略的时候应该非常爽)。。。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.servicemesh.cn/?/article/21&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
      <category term="微服务 Service Mesh" scheme="http://fudali.cc/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Service-Mesh/"/>
    
    
      <category term="Service Mesh" scheme="http://fudali.cc/tags/Service-Mesh/"/>
    
  </entry>
  
  <entry>
    <title>spring cloud 微服务异常记录与报警</title>
    <link href="http://fudali.cc/2017/11/02/spring-cloud-excepton-deal/"/>
    <id>http://fudali.cc/2017/11/02/spring-cloud-excepton-deal/</id>
    <published>2017-11-01T16:00:00.000Z</published>
    <updated>2017-11-06T02:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们的应用在线上正常运转起来了，在正常情况下我们不需要再担心任何的事情，但是bug总是不可避免的会出现；此时我们就需要一种相关的机制能够发现我们系统中的异常并通知到相关人员，不然等到用户进行反馈时才能知道发生了bug是很影响用户体验的也是不可控的，这两者都是不可接受的。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我所在的团队目前正在使用spring cloud相关套件进行微服务的开发，所以我的介绍与实践也是在该技术栈下进行，同时可能会使用到elasticsearch。<br>我们使用spring mvc来进行业务开发，feign来做restful接口远程调用框架，zuul作为服务网关来对外开放接口。这个技术栈在使用spring cloud进行开发的团队是非常常见的。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为最开始我们就有在网关记录统一的访问日志，并使用filebeat将其同步到elasticsearch以方便后期数据的查询与分析，但是只是这样子是不够的；我们想要直接能够从日志中能够判断是否发生了毕竟明确的异常，我们需要有一个点或者相关的阈值去确定什么情况是异常，可能会有bug，需要进行相关的操作去进行报警。所以我们需要在日志记录上面做一些文章，让我们记录的日志能够有足够有力和准确的信息让我们去判断是不是异常，然后去触发一系列的操作(报警等等…)。<br>经过一定的分析之后我认为异常是一个很好的判断是否有bug的点，因为没有异常不一定没有bug，但是有没有被捕获异常的请求一定是有bug的；所以以此作为切入点，深入思考。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="开发中的定制"><a href="#开发中的定制" class="headerlink" title="开发中的定制"></a>开发中的定制</h3><p>首先我们的基础架构指定了统一的错误码来对外进行提示，同时在业务层以抛出异常来对外进行提示。<br>我们将它定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DomainServerException extends Exception &#123;</div><div class="line">    // 平台定义错误码</div><div class="line">    private int code;</div><div class="line">    // http status</div><div class="line">    private int status;</div><div class="line">    // 具体错误信息，面向开发者的提示， Exception的message用于面向用户的提示</div><div class="line">    private int error;</div><div class="line">    // 相关异常的堆栈信息</div><div class="line">    private int stack;</div><div class="line"></div><div class="line">    public DomainServiceException(int code, String message, Throwable throwable) &#123;</div><div class="line">        super(message, throwable);</div><div class="line">        this.code = code;</div><div class="line">        if (isServerError())</div><div class="line">            this.stack = ExceptionUtils.getStackTrace(throwable);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中的stack信息就是为了我们进行异常追踪而添加的字段，当<code>http status为5**</code>或者<code>平台定义错误码为服务器异常</code>的时候会加载相关异常堆栈信息并设值到stack字段。具体是在<code>DomainServiceException</code>构造函数进行或者在<code>spring ErrorController</code>中进行相关设值操作(因为我们使用异常来抛出错误码，所以我们对<code>spring MVC</code>默认的<code>ErrorController</code>进行了定制)。<br>我们<code>ErrorController</code>的返回类型定义为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class HttpErrorResponse implements Serializable &#123;</div><div class="line">    private Date timestamp;</div><div class="line">    private Integer status;</div><div class="line">    private String error;</div><div class="line">    private String message;         </div><div class="line">    private String stack;           // 异常堆栈  方便记录同时在前后端调试的时候信息也更加丰富</div><div class="line">    private String exception;       // 异常类型</div><div class="line">    private String path;            // 错误请求路径</div><div class="line">    private Integer errorCode;      // 平台定义错误码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于错误的情况我们抛出<code>DomainServerException</code>或者其他未捕获异常，<code>DomainServerException</code>默认为我们的业务错误，同时也可作为异常错误，但是我们在进行异常错误处理为<code>DomainServerException</code>是会将上层异常堆栈传入构造函数生成<code>DomainServerException</code>异常对象(<code>注意:此模式下一定不要去处理你不知道该怎么处理的异常，如果你处理不了就一直往外抛，ErroController能够正确的处理并记录他然后供报警使用</code>)。<br>此时我们抛出的<code>HttpErrorResponse</code>可能会被两个地方用到:</p>
<ol>
<li>服务之间的调用</li>
<li>zuul转发来的请求</li>
</ol>
<ul>
<li><p>对于第一种情况，因为我们使用<code>feign</code>来进行服务间远程调用，我们重写了<code>ErrorDecoder</code>来进行<code>HttpErrorResponse</code>与<code>DomainServerException</code>或者<code>DomainServerException的子类</code>(通过exception字段来进行类型判断)并向外抛出。级联调用一次类推，最终都会到网关一层进行处理。所以第一种情况最终也会变为第二种情况。</p>
</li>
<li><p>对于第二种情况我们，因为我们有错误码的定义并且在正常情况下我们也会返回错误，但是正常的结果却是没有错误码的，所以我们在<code>zuul</code>实现了一个<code>type为“post”的filter来对返回值进行格式化，同时也对老的平台与新的平台进行输出格式化</code>。在这里面我们判断服务返回的内容是否有异常并进行相关的记录(存入相关信息到<code>RequestContext</code>)，最后在统一日志记录Filter(包含正常filter和zuul 异常filter)进行统一记录相关信息。同时因为我们在zuul也写了一些胶水接口，所以我们在Zuul继承了普通服务的ErroController实现了ZuulErrorController同时也会记录异常信息。</p>
</li>
</ul>
<h3 id="日志的储存和报警"><a href="#日志的储存和报警" class="headerlink" title="日志的储存和报警"></a>日志的储存和报警</h3><p>记录怎么样的日志已经确定了，我们使用filebeat来讲日志数据传输到elasticsearch中。现在我们elasticsearch中就有错误码和stack的信息了，很明显，stack信息是很明显的错误信息，紫瑶该字段一出现就表示我们的代码又问题，我们可以根据这个很好的去报警。对于错误码信息，可能会比较复杂，我们需要判断他在某些情况下的一个阈值，当我们在某种情况下相关错误码超过了该阈值就报警(目前该块的应用还需要多思考)<br>对于elasticsearch查询报警的工具有<a href="https://github.com/fudali113/esalert" target="_blank" rel="external">elastalert</a>,但是我对于该工具不是很感冒，同时我也疲于应对python部署那些复杂的依赖，我正在使用golang开发一款功能更简洁，学习成本更低的工具。如果在内部试用的还行应该会进行开源。</p>
<p><code>未完待续</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们的应用在线上正常运转起来了，在正常情况下我们不需要再担心任何的事情，但是bug总是不可避免的会出现；此时我们就需要一种相关的机制能够发
    
    </summary>
    
      <category term="微服务 监控" scheme="http://fudali.cc/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="spring cloud" scheme="http://fudali.cc/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>zuul业务检查相关模块</title>
    <link href="http://fudali.cc/2017/05/21/zuul-biz-check/"/>
    <id>http://fudali.cc/2017/05/21/zuul-biz-check/</id>
    <published>2017-05-20T16:00:00.000Z</published>
    <updated>2017-05-21T13:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用spring cloud进行微服务开发的过程中，因为微服务之间的访问只是对资源的访问，不应该有权限相关的检验，但是对外开放的服务是必须要对没有用户所能访问的资源与操作进行权限检验的。<br>而spring cloud的网关服务开源项目并没有很好地提供业务检查相关的处理模块，所以我在使用zuul进行网关开发的过程中根据自己的理解写了一套业务检查相关的代码。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>业务相关的权限检查因为每个微服务所需要的检查是不一样的，所以不同的微服务可能需要不同的检查，且同意微服务内不同的接口路径和HTTP方法的检查策略也可能是不同的，所以检查应该可以确切到每一个访问。</p>
<p>业务检查虽然是在网关进行检查的，但是为了降低耦合与提高内聚。实际检查的处理逻辑也应该是由微服务内部提供，并对外提供接口。我们在网关进行检查的时候也应该是请求相关的接口检查权限。</p>
<p>zuul权限检查模块的实现思路大致是可以在配置文件中配置微服务相关路由的检查器(实现BusinessChecker接口的实现类)，根据检查内容抛出错误或者通过检查。</p>
<p>在代码的实现上时，提供BusinessChecker接口供需要检查的权限实现，拥有<code>type(),order(),check(CheckContext ct)</code>方法并且该接口默认实现了<code>Comparable&lt;BusinessChecker&gt;</code>,</p>
<ul>
<li>type :返回改checker的type，用于在配置文件中配置路由相关处理器的type时使用</li>
<li>order :返回执行时的顺序</li>
<li>check :进行实际的检查内容，一般以抛出异常为检验错误。</li>
</ul>
<p>CheckContext :是从Zull requestContext 切换过来的上下文，主要是为了与Zuul的解耦</p>
<p>CheckException :检查时可抛出的错误，包含Http status, BizCode, 错误信息。</p>
<p>CheckManager :管理根据路由获取相关Checker的管理类，首先根据相关配置获取个Checker的type，在根据type查找在spring中的相关bean，最后排序并返回改请求所对应的相关Check实体数组。</p>
<p>BusinessVerifyFilter :主要是衔接Check模块与Zuul之间的桥梁 </p>
<p>CheckProperties :加载相关的配置文件</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/23mf/zuul-biz-check" target="_blank" rel="external">zuul-biz-check</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在使用spring cloud进行微服务开发的过程中，因为微服务之间的访问只是对资源的访问，不应该有权限相关的检验，但是对外开放的服务是必须
    
    </summary>
    
      <category term="微服务" scheme="http://fudali.cc/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="spring cloud" scheme="http://fudali.cc/tags/spring-cloud/"/>
    
      <category term="zuul" scheme="http://fudali.cc/tags/zuul/"/>
    
  </entry>
  
  <entry>
    <title>4.22 thoughtWorks 学习</title>
    <link href="http://fudali.cc/2017/04/22/tw-learn-4.22/"/>
    <id>http://fudali.cc/2017/04/22/tw-learn-4.22/</id>
    <published>2017-04-21T16:00:00.000Z</published>
    <updated>2017-04-22T03:01:11.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="容器技术" scheme="http://fudali.cc/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="docker" scheme="http://fudali.cc/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>springbox-swagger2使用</title>
    <link href="http://fudali.cc/2017/04/20/springbox-swagger2-conflict-feignclient/"/>
    <id>http://fudali.cc/2017/04/20/springbox-swagger2-conflict-feignclient/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2017-05-04T09:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="与FeignClient冲突"><a href="#与FeignClient冲突" class="headerlink" title="与FeignClient冲突"></a>与FeignClient冲突</h2><ul>
<li>Q:<br>  使用springbox-swagger2 2.2.2版本进行注释api生成文档，但是当basePackage路径下存在feignClient注释的类时，将会报NullPointerException.出现这种情况是因为2.2.2版本没有对feignClient初始化时调用refreshContext作兼容。</li>
<li>A:<br>  升级版本到最新版，在2.5.0中改问题被彻底解决;<a href="https://github.com/springfox/springfox/issues/1074" target="_blank" rel="external">springbox-swagger2 github issue 1074</a>;</li>
</ul>
<p>“111-1141-9124”,”111-1143-6985”,”111-1145-2039”,”111-1144-0685”</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;与FeignClient冲突&quot;&gt;&lt;a href=&quot;#与FeignClient冲突&quot; class=&quot;headerlink&quot; title=&quot;与FeignClient冲突&quot;&gt;&lt;/a&gt;与FeignClient冲突&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Q:&lt;br&gt;  使用spring
    
    </summary>
    
      <category term="微服务" scheme="http://fudali.cc/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="swagger" scheme="http://fudali.cc/tags/swagger/"/>
    
      <category term="spring cloud" scheme="http://fudali.cc/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>word pattern 实现</title>
    <link href="http://fudali.cc/2017/04/15/woed_pattern/"/>
    <id>http://fudali.cc/2017/04/15/woed_pattern/</id>
    <published>2017-04-14T16:00:00.000Z</published>
    <updated>2017-04-15T14:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://leetcode.com/problems/word-pattern/#/description" target="_blank" rel="external">leetcode第290题</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func wordPattern(pattern string, str string) bool &#123;</div><div class="line">    singleStrs := strings.Split(str, &quot; &quot;)</div><div class="line">    if len(pattern) != len(singleStrs) &#123;</div><div class="line">        return false</div><div class="line">    &#125;</div><div class="line">    for i := 0; i &lt; len(pattern); i++ &#123;</div><div class="line">        singleP := pattern[i]</div><div class="line">        singleStr := singleStrs[i]</div><div class="line">        for j := 0; j &lt; len(pattern); j++ &#123;</div><div class="line">            if i == j &#123;</div><div class="line">                continue</div><div class="line">            &#125;</div><div class="line">            _singleP := pattern[j]</div><div class="line">            _singleStr := singleStrs[j]</div><div class="line">            if singleP == _singleP &amp;&amp; singleStr != _singleStr &#123;</div><div class="line">                return false</div><div class="line">            &#125;</div><div class="line">            switch &#123;</div><div class="line">            case singleP == _singleP &amp;&amp; singleStr != _singleStr: </div><div class="line">                return false</div><div class="line">            case singleP != _singleP &amp;&amp; singleStr == _singleStr:</div><div class="line">                return false</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    return true</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/word-pattern/#/description&quot; tar
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="http://fudali.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://fudali.cc/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>fastjson反序列化异常类</title>
    <link href="http://fudali.cc/2017/03/29/fastjson-desrialze-exception/"/>
    <id>http://fudali.cc/2017/03/29/fastjson-desrialze-exception/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-03-29T03:01:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>因为公司本使用fastjson进行json数据序列化与反序列化。<br>最近正准备实践微服务，可能需要在各服务之间传递异常，顾将异常信息序列化传输在反序列化。<br>本以为fastjson根据setter进行反序列化相关操作，但是实际情况有些差距，我自定义的一些字段并没有被反序列化。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>如下，我的异常结构体是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class BaseException extends FeignException &#123;</div><div class="line"></div><div class="line">    private int code;</div><div class="line"></div><div class="line">    public BaseException()&#123;</div><div class="line">        super(&quot;&quot;, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected BaseException(int code, String message, Throwable cause) &#123;</div><div class="line">        super(message, cause);</div><div class="line">        this.code = code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getCode() &#123;</div><div class="line">        return code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCode(int code) &#123;</div><div class="line">        this.code = code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我接收到的json数据是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;code&quot;: 133,</div><div class="line">    &quot;message&quot;: &quot;ooo&quot;,</div><div class="line">    &quot;stackTrace&quot;: [...],</div><div class="line">    &quot;rootCause&quot;: &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是反序列化后我得到的实体却只有stackTrace信息，并没有code和message信息，只有debug追踪代码找原因。<br>最后找到DefaultJSONParse.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T parseObject(Type type, Object fieldName) &#123;</div><div class="line">        int token = lexer.token();</div><div class="line">        if (token == JSONToken.NULL) &#123;</div><div class="line">            lexer.nextToken();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (token == JSONToken.LITERAL_STRING) &#123;</div><div class="line">            if (type == byte[].class) &#123;</div><div class="line">                byte[] bytes = lexer.bytesValue();</div><div class="line">                lexer.nextToken();</div><div class="line">                return (T) bytes;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (type == char[].class) &#123;</div><div class="line">                String strVal = lexer.stringVal();</div><div class="line">                lexer.nextToken();</div><div class="line">                return (T) strVal.toCharArray();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 这里会根据类型获取相关的反序列化类型，Exception Type对应ThrowableDeserializer反序列化类</div><div class="line">        ObjectDeserializer derializer = config.getDeserializer(type);</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            return (T) derializer.deserialze(this, type, fieldName);</div><div class="line">        &#125; catch (JSONException e) &#123;</div><div class="line">            throw e;</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            throw new JSONException(e.getMessage(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>ThrowableDeserializer在初始化异常类的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">private Throwable createException(String message, Throwable cause, Class&lt;?&gt; exClass) throws Exception &#123;</div><div class="line">        Constructor&lt;?&gt; defaultConstructor = null;</div><div class="line">        Constructor&lt;?&gt; messageConstructor = null;</div><div class="line">        Constructor&lt;?&gt; causeConstructor = null;</div><div class="line">        for (Constructor&lt;?&gt; constructor : exClass.getConstructors()) &#123;</div><div class="line">        	Class&lt;?&gt;[] types = constructor.getParameterTypes();</div><div class="line">            if (types.length == 0) &#123;</div><div class="line">                defaultConstructor = constructor;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (types.length == 1 &amp;&amp; types[0] == String.class) &#123;</div><div class="line">                messageConstructor = constructor;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (types.length == 2 &amp;&amp; types[0] == String.class &amp;&amp; types[1] == Throwable.class) &#123;</div><div class="line">                causeConstructor = constructor;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (causeConstructor != null) &#123;</div><div class="line">            return (Throwable) causeConstructor.newInstance(message, cause);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (messageConstructor != null) &#123;</div><div class="line">            return (Throwable) messageConstructor.newInstance(message);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (defaultConstructor != null) &#123;</div><div class="line">            return (Throwable) defaultConstructor.newInstance();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>从最下面的三个if判断可以看出，ThrowableDeserializer是根据构造函数来进行初始化实体的且值支持三种类型，最开始我的构造函数只有无参构造满足最后一个，所以最后出来的数据都为空，除了堆栈。<br>那堆栈为何不为空呢？<br>因为在ThrowableDeserializer的deserialze()的最后有一段这样的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (stackTrace != null) &#123;</div><div class="line">            ex.setStackTrace(stackTrace);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>so…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用fastjson反序列化Exception类时一定要给出确定的构造函数且与之对应。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;因为公司本使用fastjson进行json数据序列化与反序列化。&lt;br&gt;最近正准备实践微服务，可能需要在各服务之间传递异常，顾将异常信息序列
    
    </summary>
    
      <category term="笔记" scheme="http://fudali.cc/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="fastjson" scheme="http://fudali.cc/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>排序-堆排序</title>
    <link href="http://fudali.cc/2017/03/25/heap-sort/"/>
    <id>http://fudali.cc/2017/03/25/heap-sort/</id>
    <published>2017-03-24T16:00:00.000Z</published>
    <updated>2017-03-25T09:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>堆排序是利用堆的特性实现的排序方式;<br>因为最小堆始终保证堆顶元素为最小值，且每此获取操作为logN;<br>顾堆排序为NlogN的时间复杂度</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package heap</div><div class="line"></div><div class="line">import &quot;github.com/fudali113/learn-basic/adt&quot;</div><div class="line"></div><div class="line">// HeapSort 堆排序</div><div class="line">func HeapSort(array []int) &#123;</div><div class="line">	arrayLen := len(array)</div><div class="line">	minHeap := adt.GetHeap(false)</div><div class="line">	minHeap.Insert(array...)</div><div class="line">	for i := 0; i &lt; arrayLen; i++ &#123;</div><div class="line">		array[i], _ = minHeap.Delete()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>时间复杂度: NlogN<br>是否稳定: 不稳定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;堆排序是利用堆的特性实现的排序方式;&lt;br&gt;因为最小堆始终保证堆顶元素为最小值，且每此获取操作为logN;&lt;br&gt;顾堆排序为NlogN的时间
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>consul权限控制</title>
    <link href="http://fudali.cc/2017/03/24/consul-acl/"/>
    <id>http://fudali.cc/2017/03/24/consul-acl/</id>
    <published>2017-03-23T16:00:00.000Z</published>
    <updated>2017-03-25T04:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近公司准备实践微服务，在服务发现与注册方面选择了consul；<br>主要是基于易用与功能全面的考虑；</p>
<p>因为之前只是有点点初步的理解，并没有去深入的了解与实践，实践的时候发现consul的权限控制有一点不好理解；<br>所以只有跟我们老大(大波哥)一起去踩坑；</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li><p>  consul的acl控制默认是关闭的，需要在任意配置文件中添加<code>acl_master_token</code>配置项<br>  此时默认的控制策略是可写的(<code>acl_default_policy为write</code>)<br>  因为consul默认有匿名token(即<code>anonymous</code>),此token当用户acl开启且用户token为空时默认使用该token<br>  因为此时默认策略为全部可写，此时<code>anonymous</code>也拥有全部的权限包括acl的读写权限<br>  顾想要设置权限控制应该使<code>acl_default_policy为deny</code>，此时默认权限控制为全部否定。</p>
</li>
<li><p>  当配置之后可能会发现打开ui依然可见自己的consul服务，这一点会让人很奇怪，这是consul在检测服务时默认不检测consul服务的权限：</p>
<p>  <code>consul/consul/acl.go#347</code> version：v0.7.5</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// allowService is used to determine if a service is accessible for an ACL.</div><div class="line">func (f *aclFilter) allowService(service string) bool &#123;</div><div class="line">    if service == &quot;&quot; || service == ConsulServiceID &#123;</div><div class="line">        return true</div><div class="line">    &#125;</div><div class="line">    return f.acl.ServiceRead(service)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <a href="https://github.com/hashicorp/consul/issues/2816" target="_blank" rel="external">github issue # 2816</a></p>
<p>  这个貌似可以使使用<code>enforceVersion8</code>进行控制，未实现</p>
</li>
</ul>
<ul>
<li>  对于ui中多次输错token出现403页面，可以使用清除浏览器缓存或者换个浏览器进入ui界面，这应该做的一定的安全举措</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近公司准备实践微服务，在服务发现与注册方面选择了consul；&lt;br&gt;主要是基于易用与功能全面的考虑；&lt;/p&gt;
&lt;p&gt;因为之前只是有点点初
    
    </summary>
    
      <category term="微服务" scheme="http://fudali.cc/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="consul" scheme="http://fudali.cc/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-对顶堆</title>
    <link href="http://fudali.cc/2017/03/22/adt-median-heap/"/>
    <id>http://fudali.cc/2017/03/22/adt-median-heap/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-22T14:58:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对顶堆，用于实时求解中位数<br>用一个最大堆和一个最小堆组成一个结构体<br>对插入元素进行操作并使最大堆元素与最少堆元素最多只能有一个交点(集两个堆顶相等)且保证两个堆的长度差距不能大于1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">package adt</div><div class="line"></div><div class="line">import &quot;log&quot;</div><div class="line"></div><div class="line">// MedianHeap 实时求解中位数堆</div><div class="line">type MedianHeap struct &#123;</div><div class="line">	min *Heap</div><div class="line">	max *Heap</div><div class="line">&#125;</div><div class="line"></div><div class="line">// GetMedianHeap 获取一个中位数堆</div><div class="line">func GetMedianHeap() MedianHeap &#123;</div><div class="line">	return MedianHeap&#123;min: GetHeap(false), max: GetHeap(true)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Len 获取实际长度</div><div class="line">func (mh MedianHeap) Len() int &#123;</div><div class="line">	return mh.min.Len() + mh.max.Len()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Insert 添加一个元素</div><div class="line">func (mh MedianHeap) Insert(value int) &#123;</div><div class="line">	if mh.min.Len() == 0 &#123;</div><div class="line">		mh.min.Insert(value)</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	if mh.max.Len() == 0 &#123;</div><div class="line">		minValue, _ := mh.min.Get()</div><div class="line">		if value &gt; minValue &#123;</div><div class="line">			mh.min.Delete()</div><div class="line">			mh.min.Insert(value)</div><div class="line">			mh.max.Insert(minValue)</div><div class="line">		&#125; else &#123;</div><div class="line">			mh.max.Insert(value)</div><div class="line">		&#125;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if mh.insertMin(value) &#123;</div><div class="line">		mh.min.Insert(value)</div><div class="line">	&#125; else &#123;</div><div class="line">		mh.max.Insert(value)</div><div class="line">	&#125;</div><div class="line">	mh.reset()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// GetMedian 实时获取中位数</div><div class="line">func (mh MedianHeap) GetMedian() (median float32) &#123;</div><div class="line">	log.Println(&quot;GetMedian log:&quot;, mh.min, &quot;---&quot;, mh.max)</div><div class="line">	minL, maxL := mh.min.Len(), mh.max.Len()</div><div class="line">	if mh.Len() == 0 &#123;</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	gap := minL - maxL</div><div class="line">	switch gap &#123;</div><div class="line">	case 1:</div><div class="line">		minV, _ := mh.min.Get()</div><div class="line">		median = float32(minV)</div><div class="line">	case 0:</div><div class="line">		minV, _ := mh.min.Get()</div><div class="line">		maxV, _ := mh.max.Get()</div><div class="line">		median = (float32(minV) + float32(maxV)) / 2</div><div class="line">	case -1:</div><div class="line">		maxV, _ := mh.max.Get()</div><div class="line">		median = float32(maxV)</div><div class="line">	default:</div><div class="line">		mh.reset()</div><div class="line">		mh.GetMedian()</div><div class="line">	&#125;</div><div class="line">	return</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (mh MedianHeap) insertMin(value int) bool &#123;</div><div class="line">	minV, _ := mh.min.Get()</div><div class="line">	maxV, _ := mh.max.Get()</div><div class="line">	minL, maxL := mh.min.Len(), mh.max.Len()</div><div class="line">	if value &gt; minV &#123;</div><div class="line">		return true</div><div class="line">	&#125; else if value &gt;= maxV &#123;</div><div class="line">		if minL &gt; maxL &#123;</div><div class="line">			return false</div><div class="line">		&#125;</div><div class="line">		return true</div><div class="line">	&#125;</div><div class="line">	return false</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (mh MedianHeap) reset() &#123;</div><div class="line">	minL, maxL := mh.min.Len(), mh.max.Len()</div><div class="line">	gap := minL - maxL</div><div class="line">	if gap &gt;= 2 &#123;</div><div class="line">		minV, _ := mh.min.Delete()</div><div class="line">		mh.max.Insert(minV)</div><div class="line">	&#125; else if gap &lt;= -2 &#123;</div><div class="line">		maxV, _ := mh.max.Delete()</div><div class="line">		mh.min.Insert(maxV)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/adt/median_head.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TODO</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对顶堆，用于实时求解中位数&lt;br&gt;用一个最大堆和一个最小堆组成一个结构体&lt;br&gt;对插入元素进行操作并使最大堆元素与最少堆元素最多只能有一个交
    
    </summary>
    
      <category term="数据结构" scheme="http://fudali.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="ADT" scheme="http://fudali.cc/tags/ADT/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://fudali.cc/2017/03/20/adt-heap/"/>
    <id>http://fudali.cc/2017/03/20/adt-heap/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>堆又称为优先队列，支持插入和删除堆顶操作；<br>分为最小堆、最大堆、还有一种扩展实现对顶堆，常用语实时获取中位数；<br>在贪婪算法的实现即是基于堆，该算法通过反复最小元来进行操作；</p>
<h3 id="下虑插入"><a href="#下虑插入" class="headerlink" title="下虑插入"></a>下虑插入</h3><p>下虑插入主要用在delete操作，此时顶刚好空缺并且堆中少了一个元素,因此现在堆中最后一个元素(暂且命名为X)必须移动到该堆的某个位置。</p>
<p>如果X可以放入堆顶，那么delete操作完成。</p>
<p>但是这一般不太可能，因此我们将空缺位置的两个儿子中优先级(根据最大堆或者最小堆优先级可能不同)更大与空缺位置调换；此时空缺位置被推向想一层。重复改步鄹直到X可以放入空缺位置。</p>
<p>这种一般的策略叫做下虑；<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/percolate-down.jpeg" alt="下虑插入示意图" title="">
                </div>
                <div class="image-caption">下虑插入示意图</div>
            </figure></p>
<h3 id="上虑插入"><a href="#上虑插入" class="headerlink" title="上虑插入"></a>上虑插入</h3><p>上虑插入主要用于insert操作，此时堆中处于平衡状态，因此现在在堆尾建立一个一个空缺位置；</p>
<p>在空缺位置与其父节点进行对比优先级，若插入元素优先级更高，则将空缺位置与父节点调换位置；</p>
<p>此时空缺位置已被推上一层，重复吃步鄹直到找到合适的空缺位置。</p>
<p>这种一般的策略叫做上虑；<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/percolate-up1.jpeg" alt="上虑插入示意图1" title="">
                </div>
                <div class="image-caption">上虑插入示意图1</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/percolate-up2.jpeg" alt="上虑插入示意图2" title="">
                </div>
                <div class="image-caption">上虑插入示意图2</div>
            </figure></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line">package adt</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// Heap 堆结构</div><div class="line">// 数组形式为index为0的元素默认为空，总index为1元素开始</div><div class="line">// 方便定位元素</div><div class="line">// 即如往堆里插入1,2,3,4,5</div><div class="line">// 数组元素为[0,1,2,3,4,5]</div><div class="line">type Heap struct &#123;</div><div class="line">	array []int</div><div class="line">	isMax bool // 表示最大堆还是最小堆</div><div class="line">&#125;</div><div class="line"></div><div class="line">// GetHeap 获取一个Heap实列</div><div class="line">func GetHeap(isMax bool) *Heap &#123;</div><div class="line">	return &amp;Heap&#123;array: make([]int, 1, 8), isMax: isMax&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Insert 插入一个元素</div><div class="line">func (h *Heap) Insert(value int) &#123;</div><div class="line">	if h.array == nil &#123;</div><div class="line">		h.array = make([]int, 1, 8)</div><div class="line">	&#125;</div><div class="line">	h.array = insert(h.array, value, h.isMax)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Delete 删除并获取堆顶</div><div class="line">func (h *Heap) Delete() (top int, err error) &#123;</div><div class="line">	h.array, top, err = reset(h.array, h.isMax)</div><div class="line">	return top, err</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getCompareResult 比较</div><div class="line">func getCompareResult(o1, o2 int, isMax bool) int &#123;</div><div class="line">	if o1 == o2 &#123;</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	if isMax &#123;</div><div class="line">		if o1 &gt; o2 &#123;</div><div class="line">			return 1</div><div class="line">		&#125;</div><div class="line">		return -1</div><div class="line">	&#125;</div><div class="line">	if o1 &lt; o2 &#123;</div><div class="line">		return 1</div><div class="line">	&#125;</div><div class="line">	return -1</div><div class="line">&#125;</div><div class="line"></div><div class="line">//</div><div class="line">//</div><div class="line">// Insert 相关函数</div><div class="line">//</div><div class="line">//</div><div class="line"></div><div class="line">// insert 根据堆性质想数组中插入一个元素</div><div class="line">func insert(array []int, value int, isMax bool) (nowArray []int) &#123;</div><div class="line">	nowArray = append(array, 0)</div><div class="line">	insertIndex := getInsertIndex(nowArray, len(array), value, isMax)</div><div class="line">	nowArray[insertIndex] = value</div><div class="line">	return nowArray</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getInsertIndex 递归获取插入元素的数组下标</div><div class="line">// 使用上虑策略</div><div class="line">func getInsertIndex(array []int, nowIndex int, value int, isMax bool) int &#123;</div><div class="line">	if nowIndex &lt; 2 &#123;</div><div class="line">		return 1</div><div class="line">	&#125;</div><div class="line">	faIndex := getFaIndex(nowIndex)</div><div class="line">	if getCompareResult(array[faIndex], value, isMax) &gt;= 0 &#123;</div><div class="line">		return nowIndex</div><div class="line">	&#125;</div><div class="line">	array[faIndex], array[nowIndex] = array[nowIndex], array[faIndex]</div><div class="line">	return getInsertIndex(array, faIndex, value, isMax)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getFaIndex 获取一个元素的父级元素数组下标</div><div class="line">func getFaIndex(index int) int &#123;</div><div class="line">	return index / 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">//</div><div class="line">//</div><div class="line">// Delete 相关函数</div><div class="line">//</div><div class="line">//</div><div class="line"></div><div class="line">const (</div><div class="line">	noGo = iota</div><div class="line">	goLeft</div><div class="line">	goRight</div><div class="line">)</div><div class="line"></div><div class="line">// reset 重设置一个数组</div><div class="line">func reset(array []int, isMax bool) (nowArray []int, topValue int, err error) &#123;</div><div class="line">	lastIndex := len(array) - 1</div><div class="line">	if lastIndex == 1 &#123;</div><div class="line">		topValue = array[1]</div><div class="line">		nowArray = array[:lastIndex]</div><div class="line">		return</div><div class="line">	&#125; else if lastIndex &lt; 1 &#123;</div><div class="line">		return array, 0, fmt.Errorf(&quot;堆中已无元素&quot;)</div><div class="line">	&#125;</div><div class="line">	topValue, array[1] = array[1], 0</div><div class="line">	value := array[len(array)-1]</div><div class="line">	nowArray = array[:len(array)-1]</div><div class="line">	lastInsertIndex := getLastInsertIndex(nowArray, 1, value, isMax)</div><div class="line">	nowArray[lastInsertIndex] = value</div><div class="line">	return</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getLastInsertIndex 下虑</div><div class="line">func getLastInsertIndex(array []int, nowIndex int, value int, isMax bool) int &#123;</div><div class="line">	status := noGo</div><div class="line">	lastIndex := len(array) - 1</div><div class="line">	leftIndex, rightIndex := getSonIndex(nowIndex)</div><div class="line">	if lastIndex &gt;= rightIndex &#123;</div><div class="line">		left, right := array[leftIndex], array[rightIndex]</div><div class="line">		status = getStatus(left, right, value, isMax)</div><div class="line">	&#125; else if lastIndex == leftIndex &amp;&amp; getCompareResult(array[leftIndex], value, isMax) &gt;= 0 &#123;</div><div class="line">		status = goLeft</div><div class="line">	&#125;</div><div class="line">	switch status &#123;</div><div class="line">	case noGo:</div><div class="line">		return nowIndex</div><div class="line">	case goLeft:</div><div class="line">		array[nowIndex], array[leftIndex] = array[leftIndex], value</div><div class="line">		return getLastInsertIndex(array, leftIndex, value, isMax)</div><div class="line">	case goRight:</div><div class="line">		array[nowIndex], array[rightIndex] = array[rightIndex], value</div><div class="line">		return getLastInsertIndex(array, rightIndex, value, isMax)</div><div class="line">	&#125;</div><div class="line">	panic(&quot;--&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getSonIndex 获取一个元素的左右子元素数组下标</div><div class="line">func getSonIndex(index int) (left, right int) &#123;</div><div class="line">	return 2 * index, 2*index + 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">// getStatus 根据三个值获取走那边获取步鄹</div><div class="line">func getStatus(left, right, value int, isMax bool) (res int) &#123;</div><div class="line">	res = 0</div><div class="line">	if getCompareResult(left, value, isMax) &gt; 0 || getCompareResult(right, value, isMax) &gt; 0 &#123;</div><div class="line">		res++</div><div class="line">	&#125; else &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	if getCompareResult(right, left, isMax) &gt; 0 &#123;</div><div class="line">		res++</div><div class="line">	&#125;</div><div class="line">	return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/adt/head.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>插入时间复杂度：O(logN)</p>
<p>堆的实现确实惊为天人，如何的有魅力。<br>特别是上虑与下虑策略的思想，真是让人大开眼界。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;堆又称为优先队列，支持插入和删除堆顶操作；&lt;br&gt;分为最小堆、最大堆、还有一种扩展实现对顶堆，常用语实时获取中位数；&lt;br&gt;在贪婪算法的实现
    
    </summary>
    
      <category term="数据结构" scheme="http://fudali.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="ADT" scheme="http://fudali.cc/tags/ADT/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序知识总结</title>
    <link href="http://fudali.cc/2017/03/20/sort/"/>
    <id>http://fudali.cc/2017/03/20/sort/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-25T09:09:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h2><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p>
<p>堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。</p>
<h2 id="各算法时间复杂度与是否稳定"><a href="#各算法时间复杂度与是否稳定" class="headerlink" title="各算法时间复杂度与是否稳定"></a>各算法时间复杂度与是否稳定</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/sort.jpg" alt="各算法时间复杂度与是否稳定对照表" title="">
                </div>
                <div class="image-caption">各算法时间复杂度与是否稳定对照表</div>
            </figure>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://juejin.im/post/58ca051f61ff4b0060165122#数据结构" target="_blank" rel="external">掘金算法文章,包含各种算法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序算法稳定性&quot;&gt;&lt;a href=&quot;#排序算法稳定性&quot; class=&quot;headerlink&quot; title=&quot;排序算法稳定性&quot;&gt;&lt;/a&gt;排序算法稳定性&lt;/h2&gt;&lt;p&gt;假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux常用知识</title>
    <link href="http://fudali.cc/2017/03/20/linux/"/>
    <id>http://fudali.cc/2017/03/20/linux/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-20T09:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /var/log/messages</div></pre></td></tr></table></figure>
<h2 id="linux内存不足时kill进程策略"><a href="#linux内存不足时kill进程策略" class="headerlink" title="linux内存不足时kill进程策略"></a>linux内存不足时kill进程策略</h2><p>OOM_killer是Linux自我保护的方式，在内存不足时将被唤醒，调出<code>/proc/{pid}/oom_score</code>最大者并将之kill掉</p>
<p>为了保护重要进程不被OOM_killer kill掉，可以配置<code>/proc/{pid}/oom_score_adj</code>,此值为内核在为每个进行打分时的附加值，最后得分等于实际值+该值<br>顾可以使用<code>echo -20 &gt; /proc/{pid}/oom_score_adj</code>为实际值减去20(最后得分越小越不易被杀掉)</p>
<p>root进程默认获取-30的附加值<br><a href="http://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/" target="_blank" rel="external">详细来源，从源码的角度讲解</a><br><a href="https://github.com/torvalds/linux/blob/master/mm/oom_kill.c#L172-L222" target="_blank" rel="external">计算oom_score的函数linux源码</a></p>
<p>获取进程oom_score脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">for proc in $(find /proc -maxdepth 1 -regex &apos;/proc/[0-9]+&apos;); do</div><div class="line">    printf &quot;%2d %5d %s\n&quot; \</div><div class="line">        &quot;$(cat $proc/oom_score)&quot; \</div><div class="line">        &quot;$(basename $proc)&quot; \</div><div class="line">        &quot;$(cat $proc/cmdline | tr &apos;\0&apos; &apos; &apos; | head -c 50)&quot;</div><div class="line">done 2&gt;/dev/null | sort -nr | head -n 10</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内核日志&quot;&gt;&lt;a href=&quot;#内核日志&quot; class=&quot;headerlink&quot; title=&quot;内核日志&quot;&gt;&lt;/a&gt;内核日志&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="linux" scheme="http://fudali.cc/categories/linux/"/>
    
    
      <category term="linux" scheme="http://fudali.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>排序-快速排序</title>
    <link href="http://fudali.cc/2017/03/18/quick-sort/"/>
    <id>http://fudali.cc/2017/03/18/quick-sort/</id>
    <published>2017-03-17T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速排序是实践中一种快速的排序方式；他的平均运行时间是O(NlogN)，最坏运行时间是O(N^2)，但稍加努力可使最坏情形极难出现。<br>并且可通过与堆排序的结果，可以使几乎所有的输入都能达到快速排序的快速运行时间。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>快速排序可划分为简单的四个步骤(设输入数组为array)：</p>
<ul>
<li>如果array中元素是0或者1，直接返回</li>
<li>取array中任一元素pivot，称之为枢纽元(pivot)</li>
<li>将array中不包含pivot按与pivot的比较大小划分成连个不相交的集合</li>
<li>递归对划分的两个合集进行该四步走并获得返回值与pivot合并成返回数组</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">package quick</div><div class="line"></div><div class="line">// QuickSort 快速排序</div><div class="line">// 是否稳定?</div><div class="line">// 不稳定 可以试着分析下[5,1,2,2,3,4,5]</div><div class="line">func QuickSort(array []int) &#123;</div><div class="line">	quickSort(array, 0, len(array))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// quickSort 快速排序私有递归方法</div><div class="line">func quickSort(array []int, left, right int) &#123;</div><div class="line">	if right-left &lt; 2 &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line">	medianIndex := median3(array, left, right)</div><div class="line">	nowMedianIndex := swap(array, left, right, medianIndex)</div><div class="line">	quickSort(array, left, nowMedianIndex)</div><div class="line">	quickSort(array, nowMedianIndex+1, right)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// swap 按最开始的中位置下标将数组分为比中位置大和比中位值小的两个数组</div><div class="line">// left right 遵循右开左闭</div><div class="line">// return 划分后的中位值下标</div><div class="line">func swap(array []int, left, right, medianIndex int) (nowMedianIndex int) &#123;</div><div class="line">	median := array[medianIndex]</div><div class="line">	array[medianIndex], array[right-1] = array[right-1], median</div><div class="line">	leftPoint := left</div><div class="line">	rightPoint := right - 2</div><div class="line">	leftStop := false</div><div class="line">	rightStop := false</div><div class="line">	for &#123;</div><div class="line">		// 如果左滑动指针停止，不做任何操作，等待右滑动指针也停止交换</div><div class="line">		if !leftStop &#123;</div><div class="line">			if array[leftPoint] &lt;= median &#123;</div><div class="line">				leftPoint++</div><div class="line">			&#125; else &#123;</div><div class="line">				leftStop = true</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if !rightStop &#123;</div><div class="line">			if array[rightPoint] &gt;= median &#123;</div><div class="line">				rightPoint--</div><div class="line">			&#125; else &#123;</div><div class="line">				rightStop = true</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//当左滑动指针与右滑动指针相交后，左滑动指针位置一定处于大于等于中位值的位置</div><div class="line">		if leftPoint &gt; rightPoint &#123;</div><div class="line">			array[leftPoint], array[right-1] = array[right-1], array[leftPoint]</div><div class="line">			nowMedianIndex = leftPoint</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 如果都停止，交换位置并重启滑动</div><div class="line">		if leftStop &amp;&amp; rightStop &#123;</div><div class="line">			array[leftPoint], array[rightPoint] = array[rightPoint], array[leftPoint]</div><div class="line">			leftStop, rightStop = false, false</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// median3 三数中值分割法</div><div class="line">// 比较数组开头，结尾和中间位置的值，放回处于中间的值得数组下标</div><div class="line">// return 中位值数组下标</div><div class="line">func median3(array []int, left, right int) int &#123;</div><div class="line">	index := (right + left - 1) / 2</div><div class="line">	start := array[left]</div><div class="line">	median := array[index]</div><div class="line">	end := array[right-1]</div><div class="line">	if median &gt; start &#123;</div><div class="line">		if median &lt;= end &#123;</div><div class="line">			return index</div><div class="line">		&#125; else if end &gt;= start &#123;</div><div class="line">			return right - 1</div><div class="line">		&#125; else &#123;</div><div class="line">			return left</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		if median &gt;= end &#123;</div><div class="line">			return index</div><div class="line">		&#125; else if start &gt;= end &#123;</div><div class="line">			return right - 1</div><div class="line">		&#125; else &#123;</div><div class="line">			return left</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/quick/quick.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>平均运行时间：O(NlogN)<br>最坏运行时间：O(N^2)<br>是否稳定：不稳定，试着分析[5,1,2,2,3,4,5]即可找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">选取枢纽元为2，是枢纽元到数组末尾</div><div class="line">5   1   2   5   3   4   2</div><div class="line">i                   j</div><div class="line"></div><div class="line">进行第一次交换的地方</div><div class="line">5   1   2   5   3   4   2</div><div class="line">i   j</div><div class="line"></div><div class="line">第一次交换过后</div><div class="line">1   5   2   5   3   4   2</div><div class="line">j   i</div><div class="line"></div><div class="line">此时 i &gt; j 将枢纽元从末尾与i位置元素调换</div><div class="line">1   2   2   5   3   4   5</div><div class="line"></div><div class="line">此时作为枢纽元的2从最开始的index=3变成了index=1</div><div class="line">跑到了与之相等的index为2的元素的前面，值为5的元素也发生了相似的状况</div><div class="line">顾快速排序为不稳定的排序</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;快速排序是实践中一种快速的排序方式；他的平均运行时间是O(NlogN)，最坏运行时间是O(N^2)，但稍加努力可使最坏情形极难出现。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序-归并排序</title>
    <link href="http://fudali.cc/2017/03/17/merge-sort/"/>
    <id>http://fudali.cc/2017/03/17/merge-sort/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>归并排序体现了递归分治的策略<br>思想是将数组拆分为两段，在对两段进行想通操作，直到数组元素为1，在对数组进行排序合并</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package merge</div><div class="line"></div><div class="line">// MergeSort 归并排序</div><div class="line">func MergeSort(array []int) []int &#123;</div><div class="line">	middle := len(array) / 2</div><div class="line">	if middle &lt; 1 &#123;</div><div class="line">		return array</div><div class="line">	&#125;</div><div class="line">	return merge(MergeSort(array[:middle]), MergeSort(array[middle:]))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// merge 合并两个排好序的数组唯一组合两个元素并排好序的数组</div><div class="line">func merge(a1 []int, a2 []int) []int &#123;</div><div class="line">	a1Index := 0</div><div class="line">	a2Index := 0</div><div class="line">	res := make([]int, 0, len(a1)+len(a2))</div><div class="line">	for &#123;</div><div class="line">		if a1[a1Index] &lt;= a2[a2Index] &#123;</div><div class="line">			res = append(res, a1[a1Index])</div><div class="line">			if a1Index == len(a1)-1 &#123;</div><div class="line">				res = append(res, a2[a2Index:]...)</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">			a1Index++</div><div class="line">		&#125; else &#123;</div><div class="line">			res = append(res, a2[a2Index])</div><div class="line">			if a2Index == len(a1)-1 &#123;</div><div class="line">				res = append(res, a1[a1Index:]...)</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">			a2Index++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return res</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/merge/merge.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然归并排序的运行时间是O(NlogN)，但是他合并两个已排序数组到一个附加数组会更占用内存。</p>
<p>与其他O(NlogN)的流行算法相比，归并排序是比较元素最少的，且运行时间严重依赖于比较元素和在数组(已经临时数组)中移动元素的开销(理论上使用更少内存的算法是可能的，但所得到的算法是复杂的和不实际的)。</p>
<p>这些开销是于语言相关的(java中泛型数组中的元素是引用类型的，顾移动元素开销不大，所以归并排序是java泛型数组的默认排序方式。</p>
<p>快速排序作为基础类型的排序方式，java基础类型是值传递的，因为比较与数据移动的开销是类似的，快排使用少得多的数据移动足以补偿那些附加的比较而且还有盈余)。</p>
<p>在go中也存在相同的问题，所以在不同的输入数据选择不同的排序方式再能得到最好的性能。</p>
<p>平均运行时间：O(NlogN)<br>最坏运行时间：O(NlogN)<br>是否稳定：稳定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;归并排序体现了递归分治的策略&lt;br&gt;思想是将数组拆分为两段，在对两段进行想通操作，直到数组元素为1，在对数组进行排序合并&lt;/p&gt;
&lt;h2 i
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>tcp和udp网络协议</title>
    <link href="http://fudali.cc/2017/03/17/tcp-and-udp-protocols/"/>
    <id>http://fudali.cc/2017/03/17/tcp-and-udp-protocols/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-18T04:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。<br>在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，UDP是无连接的协议。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><ul>
<li>是传输层的一种面向连接的协议</li>
<li>处理下层的不可靠数据使之变得可靠(确定通过网络发送的数据报的状态并且如果部分已被丢弃则处理信息的重发的任务并按正确的顺序重新组合成消息以提供可靠性)</li>
<li>TCP驻留在传输层中，并仅驻留在实际处理数据报的机器上，确保数据报已从源机器到目标机器；它不驻留在简单路由数据报的设备上，因此网关中没有TCP层。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/4/40/Fig1_net_tcp.jpg" alt="tcp协议留驻在传输层示意图" title="">
                </div>
                <div class="image-caption">tcp协议留驻在传输层示意图</div>
            </figure>
</li>
</ul>
<h3 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h3><ul>
<li><p>单播协议:<br>TCP基于单播网络模型，支持两方之间的数据交换。它不支持广播或多播网络模型。</p>
</li>
<li><p>连接状态:<br>TCP使用两个端点之间的同步状态，而不是在网络内强加一个状态来支持连接。<br>该同步状态被设置为初始连接过程的一部分，因此TCP可以被认为是面向连接的协议。<br>许多协议设计旨在确保每个本地状态转换被传送到远程方并由其确认。</p>
</li>
<li><p>可靠性:</p>
<p>可靠性意味着在连接的一端传递给TCP驱动程序的八位字节流将通过网络传输，使得流作为相同的八位字节序列呈现给远程进程，顺序与生成的由发送方。这意味着协议检测数据流的分段何时已被网络丢弃，重新排序，复制或损坏。<br>在必要的情况下，发送器将重传损坏的段，以便允许接收器重建原始数据流。<br>这意味着TCP发送方必须保持所有发送数据的本地副本，直到它接收到接收方已经完成数据的准确传送的指示为止。</p>
</li>
<li><p>全双工:</p>
<p>TCP是全双工协议; 它允许双方在单个TCP连接的上下文内发送和接收数据。</p>
</li>
<li><p>流:</p>
<p>虽然TCP使用分组结构用于网络传输，但TCP是真正的流传输协议，并且应用级网络操作不透明。一些协议明确地封装每个应用事务;<br>对于每一次写，都必须有一个匹配的读。以这种方式，在网络上保留数据流到逻辑记录结构的应用派生分段。<br>TCP不保留施加在数据流上的这种隐式结构，使得在网络协议内的写和读操作之间不存在配对。<br>例如，TCP应用可以将三个数据块按顺序写入网络连接，其可以由远程读取器在单个读取操作中收集。TCP会话中使用的数据块（段）的大小在会话开始时协商。<br>发送器尝试在接收器的最大段大小，配置的发送器的最大段大小和最大可支持的非分段分组大小的限制内使用它可以用于数据传输的最大段大小网络路径（路径最大传输单元[MTU]）。<br>路径MTU周期性地刷新以适应在TCP连接活动时可能发生在网络内的任何改变。</p>
</li>
<li><p>速率适配:</p>
<p>TCP也是速率自适应协议，因为数据传输速率旨在适应网络内的主要负载条件并适应接收机的处理能力。<br>没有预定的TCP数据传输速率; 如果网络和接收器都具有额外的可用容量，则TCP发送器将尝试向网络注入更多数据以占用此可用空间。<br>相反，如果有拥塞，TCP发送方将降低其发送速率以允许网络恢复。该适配功能试图实现最高可能的数据传输速率，而不触发一致的数据丢失。</p>
</li>
</ul>
<h3 id="TCP建立连接三次握手"><a href="#TCP建立连接三次握手" class="headerlink" title="TCP建立连接三次握手"></a>TCP建立连接三次握手</h3><p>客户端发送SYN消息; 服务器发送组合对客户端的SYN的ACK并且包含服务器的SYN的消息; 然后客户端发送对服务器的SYN的ACK。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/4/46/New_tcp_action1.JPG" alt="建立连接步鄹图" title="">
                </div>
                <div class="image-caption">建立连接步鄹图</div>
            </figure></p>
<p>连接在其生命周期中经过一系列状态:</p>
<p>  侦听，SYN发送，SYN接收，建立，FIN-WAIT-1，FIN-WAIT-2，CLOSE-等待，CLOSING，LAST-ACK，TIME-WAIT和虚构状态CLOSED。CLOSED是虚构的，因为它代表没有TCP时的状态，因此没有连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">LISTEN - 表示等待来自任何远程TCP和端口的连接请求。</div><div class="line"></div><div class="line">SYN-SENT - 表示在发送连接请求之后等待匹配的连接请求。</div><div class="line"></div><div class="line">SYN-RECEIVED - 表示在接收和发送连接请求之后等待确认连接请求确认。</div><div class="line"></div><div class="line">ESTABLISHED - 表示打开连接，收到的数据可以传递给用户。连接的数据传输阶段的正常状态。</div><div class="line"></div><div class="line">FIN-WAIT-1表示等待来自远程TCP的连接终止请求，或者先前发送的连接终止请求的确认。</div><div class="line"></div><div class="line">FIN-WAIT-2 - 表示等待来自远程TCP的连接终止请求。</div><div class="line"></div><div class="line">CLOSE-WAIT - 表示等待来自本地用户的连接终止请求。</div><div class="line"></div><div class="line">CLOSING - 表示等待来自远程TCP的连接终止请求确认。</div><div class="line"></div><div class="line">LAST-ACK-表示等待先前发送到远程TCP的连接终止请求的确认（其包括对其连接终止请求的确认）。</div><div class="line"></div><div class="line">TIME-WAIT - 表示等待足够的时间通过，以确保远程TCP接收到其连接终止请求的确认。</div><div class="line"></div><div class="line">CLOSED - 根本不表示连接状态。</div></pre></td></tr></table></figure></p>
<p>  TCP连接响应事件从一个状态进行到另一个状态。事件是用户调用，OPEN，SEND，RECEIVE，CLOSE，ABORT和STATUS; 传入段，特别是包含SYN，ACK，RST和FIN标志的段; 和超时。</p>
<h3 id="连接建立和终止"><a href="#连接建立和终止" class="headerlink" title="连接建立和终止"></a>连接建立和终止</h3><ul>
<li><p>建立连接</p>
<p>只有在两个机器之间的连接不存在，两个机器都同意连接，并且两个机器都有足够的TCP资源来为连接提供服务时，才能在两台机器之间建立连接。<br>如果不满足这些条件中的任何一个，则不能进行连接。连接的接受可以由应用或系统管理例程触发。</p>
</li>
<li><p>数据传输</p>
<p>对于由机器A的TCP从ULP接收的每个数据块，TCP封装它并且以递增的序列号将其发送到机器B. 在机器B接收到消息之后，它使用增加下一个序列号的分段确认来确认它（并且因此指示它接收到该序列号的一切）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/d/d7/Ntwk_data_trans.JPG" alt="tcp传输图" title="">
                </div>
                <div class="image-caption">tcp传输图</div>
            </figure>
<p>TCP数据传输服务实际上体现了六个不同的子服务：</p>
<ul>
<li><p>全双工：使连接的两端在任何时间，甚至同时发送。</p>
</li>
<li><p>及时性：使用计时器可确保在合理的时间内传输数据。</p>
</li>
<li><p>有序：从一个应用程序发送的数据将在另一端以相同的顺序接收。这发生，尽管事实上数据报可能通过IP被无序地接收，因为TCP在将消息传递到较高层之前以正确的顺序重新组装消息。</p>
</li>
<li><p>标签：所有连接具有商定的优先级和安全值。</p>
</li>
<li><p>受控流：TCP可以通过使用缓冲区和窗口限制来调节信息流。</p>
</li>
<li><p>错误校正：校验和确保数据没有错误（在校验和算法的限制内）。</p>
</li>
</ul>
</li>
<li><p>关闭连接<br>为了关闭连接，TCP之一从ULP接收关闭原语并发出具有设置为开的FIN标志的消息。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/c/c4/Ntwk_conn_close.JPG" alt="tcp关闭连接示意图" title="">
                </div>
                <div class="image-caption">tcp关闭连接示意图</div>
            </figure>
<p>在图中，机器A的TCP发送请求以关闭具有下一个序列号的机器B的连接。机器B然后将发送对该请求及其下一个序列号的确认。随后，机器B通过其ULP将关闭消息发送到应用程序，并等待应用程序确认关闭。这一步不是绝对必要的; TCP可以在没有应用程序批准的情况下关闭连接，但是一个良好的系统会通知应用程序状态的改变</p>
</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="什么是UDP"><a href="#什么是UDP" class="headerlink" title="什么是UDP"></a>什么是UDP</h3><p> UDP是无连接和不可靠的传输协议。两个端口用于标识源和目标机器内的端点。当不需要可靠的传递时，使用用户数据报协议来代替TCP。然而，UDP从不用于发送诸如网页，数据库信息等重要数据。流式媒体例如视频，音频和其他使用UDP因为它提供速度。</p>
<h3 id="UDP的特性"><a href="#UDP的特性" class="headerlink" title="UDP的特性"></a>UDP的特性</h3><ul>
<li><p>端到端。UDP可以识别在计算机上运行的特定进程。</p>
</li>
<li><p>不可靠，无连接传递（例如USPS:UDP使用无连接通信设置。在这个UDP中不需要在发送数据之前建立连接。通信仅由数据段本身组成）。</p>
</li>
<li><p>与IP相同的尽力语义</p>
</li>
<li><p>无ack，无序列，无流量控制</p>
</li>
<li><p>丢失，复制，延迟，无序或丢失连接</p>
</li>
<li><p>快速，低开销</p>
<p>因为以上特性udp更适合:</p>
<ul>
<li>适合可靠的本地网络</li>
<li>RTP（实时传输协议</li>
</ul>
</li>
</ul>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>UDP是传输层协议。UDP是一种无连接和不可靠的协议。UDP不做流量控制，错误控制或重传坏段。UDP比TCP快。UDP通常用于流音频和视频。UDP从未用于重要的文档，如网页，数据库信息等。UDP传输由8字节头组成的段。它包含源端口，目标端口，UDP长度和校验和。UDP校验和用于检测传输段中的“错误”。</p>
<h2 id="TCP-VS-UDP"><a href="#TCP-VS-UDP" class="headerlink" title="TCP VS UDP"></a>TCP VS UDP</h2><p> 用户数据报协议（UDP）和传输控制协议（TCP）是TCP / IP协议组中传输层的“同级”。它们执行相同的角色，提供应用程序和Internet协议（IP）的数据移动功能之间的接口，但是它们以非常不同的方式实现。因此，这两种协议为高层协议提供了选择，允许每个协议根据其需要选择适当的协议。</p>
<p> 有助于说明这两种协议的最重要的基本属性以及它们如何彼此对比的表：<br> <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/5/55/Tcp%26udp.jpg" alt="tcp&udp比较图" title="">
                </div>
                <div class="image-caption">tcp&udp比较图</div>
            </figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。&lt;br&gt;在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，
    
    </summary>
    
      <category term="网络协议" scheme="http://fudali.cc/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="网络" scheme="http://fudali.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="tcp/ip" scheme="http://fudali.cc/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>排序-希尔排序</title>
    <link href="http://fudali.cc/2017/03/15/shell-sort/"/>
    <id>http://fudali.cc/2017/03/15/shell-sort/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>个人认为希尔排序是对插入排序的一种优化，<br>他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序)。<br>所以希尔排序也称为缩减增量排序<br>他相比插入排序所在的优势是，他可以一次交换两个较远距离的元素，而插入排序交换两个相聚n的元素位子需要n次交换。</p>
<p>因为他根据一个算法来决定每趟比较的距离，所以该算法的好坏也会在一定程度上决定希尔排序的性能</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 利用每次除以2的等比增量数列来决定每趟比较距离</div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	arrayLen := len(array)</div><div class="line">	for gap := arrayLen / 2; gap &gt; 0; gap /= 2 &#123;</div><div class="line">		for i := gap; i &lt; arrayLen; i++ &#123;</div><div class="line">			iv := array[i]</div><div class="line">			for j := i; j-gap &gt; 0 &amp;&amp; array[j-gap] &gt; iv; j -= gap &#123;</div><div class="line">				n++</div><div class="line">				array[j-gap], array[j] = iv, array[j-gap]</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;---------------&quot;, n)</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/shell/shell.go" target="_blank" rel="external">golang code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希尔排序的性能在实践中的性能是完全可以接受的；<br>使用希尔增量是最坏情形运行时间复杂度为O(N^2)<br>对于好的增量序列，最坏时间复杂度还可以优化</p>
<p>编程的简单特点，使它成为对适度的大量输入数据进行排序的常用算法</p>
<p>最优运行时间：O(N)<br>最坏运行时间：O(N^2)<br>是否稳定：不稳定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;个人认为希尔排序是对插入排序的一种优化，&lt;br&gt;他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序-插入排序</title>
    <link href="http://fudali.cc/2017/03/13/insertion-sort/"/>
    <id>http://fudali.cc/2017/03/13/insertion-sort/</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2017-03-20T15:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  -<br>  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模式方面的知识<br>  -<br>  今天就想来理解一下排序算法中最简单的插入排序：<br>  插入排序思路为顺序遍历数组，并在遍历中从顺序遍历到的元素倒序遍历回<br>  倒序遍历是判断相邻两个元素是否符合排序规则<br>  如果符合则停止倒序遍历<br>  如果不符合则交换相邻两个元素位置并继续倒序遍历</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ppackage main</div><div class="line"></div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	// 从1开始遍历,因为0前面没有数值</div><div class="line">	for i := 1; i &lt; len(array); i++ &#123;</div><div class="line">		// 在此处放置与在 代码1 处放置效果一样</div><div class="line">		// 因为若 jv &gt; iv 的话 ， j 与 j-1 调换位置， 下一次循环时 array[j] 依然是当初的 iv</div><div class="line">		iv := array[i]</div><div class="line">		for j := i; j &gt;= 0 &amp;&amp; array[j-1] &gt;= iv; j-- &#123;</div><div class="line">			// 代码1  iv := array[j]</div><div class="line"></div><div class="line">			// 如果 jv &gt; iv , 调换两个元素之间的位置</div><div class="line">			n++</div><div class="line">			array[j], array[j-1] = array[j-1], iv</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;----------------&quot;, n)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/insertion.go" target="_blank" rel="external">golang code on github</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Insertion &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Integer[] oo = new Integer[]&#123;34, 8, 64, 51, 32, 21&#125;;</div><div class="line">	    sort(oo);</div><div class="line">        for (Integer var : oo) &#123;</div><div class="line">            System.out.println(var);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; void sort(T[] array) &#123;</div><div class="line">        for (int i = 1; i&lt; array.length; i++) &#123;</div><div class="line">            T it = array[i];</div><div class="line">            for (int j = i; j &gt; 0; j--) &#123;</div><div class="line">                T jt = array[j - 1];</div><div class="line">                if (compare(jt, it) &lt; 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;else &#123;</div><div class="line">                    array[j] = jt;</div><div class="line">                    array[j - 1] = it;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; int compare(T o1, T o2) &#123;</div><div class="line">        return (Integer)o1 - (Integer)o2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/Insertion.java" target="_blank" rel="external">java code on github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从原理和显示方式可以看出，当数组本就按排序规则排好序时，时间复杂度最小为 O(N)；当数组为倒序时未最坏情况，测试时间复杂度为O(N^2)<br>当数组中根据排序规则倒序的元素对越多，时间复杂度越大，当数组根据排序规则完全倒序时，时间复杂度最大为 2+3+4+…+N = O(N)</p>
<p>平均运行时间：O(NlogN)<br>最坏运行时间：O(NlogN)<br>是否稳定：稳定</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  -&lt;br&gt;  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ELK学习之安装logstash</title>
    <link href="http://fudali.cc/2017/02/16/ELK-install-logstash/"/>
    <id>http://fudali.cc/2017/02/16/ELK-install-logstash/</id>
    <published>2017-02-15T16:00:00.000Z</published>
    <updated>2017-03-29T03:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ul>
<li>logstash基于jvm平台，所以安装前确认已安装jre</li>
<li>最新的logstash 5.*版本至少需要java8以上jre</li>
<li>对于Debian平台或者Redhat平台,官方推荐配置软件仓库并安装</li>
</ul>
<h3 id="Debian-Ubuntu-平台"><a href="#Debian-Ubuntu-平台" class="headerlink" title="Debian/Ubuntu 平台"></a>Debian/Ubuntu 平台</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | apt-key add -</div><div class="line">cat &gt;&gt; /etc/apt/sources.list &lt;&lt;EOF</div><div class="line">deb http://packages.elasticsearch.org/logstash/5.0/debian stable main</div><div class="line">EOF</div><div class="line">apt-get update</div><div class="line">apt-get install logstash</div></pre></td></tr></table></figure>
<p>一行一行复制输入命令行即可</p>
<p>有可能出现如下错误(也有可能是运行时出现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Could not find any executable java binary. Please install java in your PATH or set JAVA_HOME.</div></pre></td></tr></table></figure></p>
<p>此时需要修改logstash的启动配置文件，对Debian/Ubuntu系统，该文件路径为<code>/etc/logstash/startup.options</code>，其中的JAVACMD参数默认为<code>/usr/**</code>,顾导致找不到java命令，只需将改参数改为你的<code>$JAVA_HOME/bin/java</code>即可解决该错误</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>软件仓库安装后logstash bin所在路径为<code>/usr/share/logstash</code></p>
<p>直接运行简单命令行输入input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -e &apos;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>配置文件运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -f &#123;配置文件路径&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;logstash基于jvm平台，所以安装前确认已安装jre&lt;/li&gt;
&lt;li&gt;最新的logstash 5.*版本
    
    </summary>
    
      <category term="日志收集" scheme="http://fudali.cc/categories/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="ELK" scheme="http://fudali.cc/tags/ELK/"/>
    
      <category term="logstash" scheme="http://fudali.cc/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>go 1.6.2 strings split 方法改造</title>
    <link href="http://fudali.cc/2016/12/13/go1.6.2-strings-split/"/>
    <id>http://fudali.cc/2016/12/13/go1.6.2-strings-split/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2017-03-18T04:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>当调用<code>strings.Split(s,seq string)</code>时,如果seq连续出现，比如<code>s=&quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk      &quot;</code>。调用<code>slice:=strings.Split(s,&quot; &quot;)</code>将会出现<code>len(slice)!=3</code>，我认为这并不是大家希望看到的结果。</p>
<p>查看<code>strings.Split(s,seq string)</code>源码：<br><code>func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }</code></p>
<p>接着查看<code>strings.genSplit()</code>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func genSplit(s, sep string, sepSave, n int) []string &#123;</div><div class="line">	if n == 0 &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	if sep == &quot;&quot; &#123;</div><div class="line">		return explode(s, n)</div><div class="line">	&#125;</div><div class="line">	if n &lt; 0 &#123;</div><div class="line">		n = Count(s, sep) + 1</div><div class="line">	&#125;</div><div class="line">	c := sep[0]</div><div class="line">	start := 0</div><div class="line">	a := make([]string, n)</div><div class="line">	na := 0</div><div class="line">	for i := 0; i+len(sep) &lt;= len(s) &amp;&amp; na+1 &lt; n; i++ &#123;</div><div class="line">		if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			a[na] = s[start : i+sepSave]</div><div class="line">			na++</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	a[na] = s[start:]</div><div class="line">	return a[0 : na+1]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发现并没有做相关的判断就将<code>s[start : i+sepSave]</code>添加到返回数组造成出现这种情况；</p>
<p>顾在for循环中添加一个判断以达到预期返回值，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			splitStr:=s[start : i+sepSave]</div><div class="line">			if !(splitStr == sep || start==i+sepSave) &#123;</div><div class="line">				a[na] = splitStr</div><div class="line">				na++</div><div class="line">			&#125;</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后调用即可达到预期返回值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当调用&lt;code&gt;strings.Split(s,seq string)&lt;/code&gt;时,如果seq连续出现，比如&lt;code&gt;s=&amp;quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk    
    
    </summary>
    
      <category term="golang笔记" scheme="http://fudali.cc/categories/golang%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
  </entry>
  
</feed>
