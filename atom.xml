<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fudali</title>
  <subtitle>do one`s best</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fudali.cc/"/>
  <updated>2017-03-18T04:56:12.000Z</updated>
  <id>http://fudali.cc/</id>
  
  <author>
    <name>fudali</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcp和udp网络协议</title>
    <link href="http://fudali.cc/2017/03/17/tcp-and-udp-protocols/"/>
    <id>http://fudali.cc/2017/03/17/tcp-and-udp-protocols/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-18T04:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。<br>在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，UDP是无连接的协议。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><ul>
<li>是传输层的一种面向连接的协议</li>
<li>处理下层的不可靠数据使之变得可靠(确定通过网络发送的数据报的状态并且如果部分已被丢弃则处理信息的重发的任务并按正确的顺序重新组合成消息以提供可靠性)</li>
<li>TCP驻留在传输层中，并仅驻留在实际处理数据报的机器上，确保数据报已从源机器到目标机器；它不驻留在简单路由数据报的设备上，因此网关中没有TCP层。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/4/40/Fig1_net_tcp.jpg" alt="tcp协议留驻在传输层示意图" title="">
                </div>
                <div class="image-caption">tcp协议留驻在传输层示意图</div>
            </figure>
</li>
</ul>
<h3 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h3><ul>
<li><p>单播协议:<br>TCP基于单播网络模型，支持两方之间的数据交换。它不支持广播或多播网络模型。</p>
</li>
<li><p>连接状态:<br>TCP使用两个端点之间的同步状态，而不是在网络内强加一个状态来支持连接。<br>该同步状态被设置为初始连接过程的一部分，因此TCP可以被认为是面向连接的协议。<br>许多协议设计旨在确保每个本地状态转换被传送到远程方并由其确认。</p>
</li>
<li><p>可靠性:</p>
<p>可靠性意味着在连接的一端传递给TCP驱动程序的八位字节流将通过网络传输，使得流作为相同的八位字节序列呈现给远程进程，顺序与生成的由发送方。这意味着协议检测数据流的分段何时已被网络丢弃，重新排序，复制或损坏。<br>在必要的情况下，发送器将重传损坏的段，以便允许接收器重建原始数据流。<br>这意味着TCP发送方必须保持所有发送数据的本地副本，直到它接收到接收方已经完成数据的准确传送的指示为止。</p>
</li>
<li><p>全双工:</p>
<p>TCP是全双工协议; 它允许双方在单个TCP连接的上下文内发送和接收数据。</p>
</li>
<li><p>流:</p>
<p>虽然TCP使用分组结构用于网络传输，但TCP是真正的流传输协议，并且应用级网络操作不透明。一些协议明确地封装每个应用事务;<br>对于每一次写，都必须有一个匹配的读。以这种方式，在网络上保留数据流到逻辑记录结构的应用派生分段。<br>TCP不保留施加在数据流上的这种隐式结构，使得在网络协议内的写和读操作之间不存在配对。<br>例如，TCP应用可以将三个数据块按顺序写入网络连接，其可以由远程读取器在单个读取操作中收集。TCP会话中使用的数据块（段）的大小在会话开始时协商。<br>发送器尝试在接收器的最大段大小，配置的发送器的最大段大小和最大可支持的非分段分组大小的限制内使用它可以用于数据传输的最大段大小网络路径（路径最大传输单元[MTU]）。<br>路径MTU周期性地刷新以适应在TCP连接活动时可能发生在网络内的任何改变。</p>
</li>
<li><p>速率适配:</p>
<p>TCP也是速率自适应协议，因为数据传输速率旨在适应网络内的主要负载条件并适应接收机的处理能力。<br>没有预定的TCP数据传输速率; 如果网络和接收器都具有额外的可用容量，则TCP发送器将尝试向网络注入更多数据以占用此可用空间。<br>相反，如果有拥塞，TCP发送方将降低其发送速率以允许网络恢复。该适配功能试图实现最高可能的数据传输速率，而不触发一致的数据丢失。</p>
</li>
</ul>
<h3 id="TCP建立连接三次握手"><a href="#TCP建立连接三次握手" class="headerlink" title="TCP建立连接三次握手"></a>TCP建立连接三次握手</h3><p>客户端发送SYN消息; 服务器发送组合对客户端的SYN的ACK并且包含服务器的SYN的消息; 然后客户端发送对服务器的SYN的ACK。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/4/46/New_tcp_action1.JPG" alt="建立连接步鄹图" title="">
                </div>
                <div class="image-caption">建立连接步鄹图</div>
            </figure></p>
<p>连接在其生命周期中经过一系列状态:</p>
<p>  侦听，SYN发送，SYN接收，建立，FIN-WAIT-1，FIN-WAIT-2，CLOSE-等待，CLOSING，LAST-ACK，TIME-WAIT和虚构状态CLOSED。CLOSED是虚构的，因为它代表没有TCP时的状态，因此没有连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">LISTEN - 表示等待来自任何远程TCP和端口的连接请求。</div><div class="line"></div><div class="line">SYN-SENT - 表示在发送连接请求之后等待匹配的连接请求。</div><div class="line"></div><div class="line">SYN-RECEIVED - 表示在接收和发送连接请求之后等待确认连接请求确认。</div><div class="line"></div><div class="line">ESTABLISHED - 表示打开连接，收到的数据可以传递给用户。连接的数据传输阶段的正常状态。</div><div class="line"></div><div class="line">FIN-WAIT-1表示等待来自远程TCP的连接终止请求，或者先前发送的连接终止请求的确认。</div><div class="line"></div><div class="line">FIN-WAIT-2 - 表示等待来自远程TCP的连接终止请求。</div><div class="line"></div><div class="line">CLOSE-WAIT - 表示等待来自本地用户的连接终止请求。</div><div class="line"></div><div class="line">CLOSING - 表示等待来自远程TCP的连接终止请求确认。</div><div class="line"></div><div class="line">LAST-ACK-表示等待先前发送到远程TCP的连接终止请求的确认（其包括对其连接终止请求的确认）。</div><div class="line"></div><div class="line">TIME-WAIT - 表示等待足够的时间通过，以确保远程TCP接收到其连接终止请求的确认。</div><div class="line"></div><div class="line">CLOSED - 根本不表示连接状态。</div></pre></td></tr></table></figure></p>
<p>  TCP连接响应事件从一个状态进行到另一个状态。事件是用户调用，OPEN，SEND，RECEIVE，CLOSE，ABORT和STATUS; 传入段，特别是包含SYN，ACK，RST和FIN标志的段; 和超时。</p>
<h3 id="连接建立和终止"><a href="#连接建立和终止" class="headerlink" title="连接建立和终止"></a>连接建立和终止</h3><ul>
<li><p>建立连接</p>
<p>只有在两个机器之间的连接不存在，两个机器都同意连接，并且两个机器都有足够的TCP资源来为连接提供服务时，才能在两台机器之间建立连接。<br>如果不满足这些条件中的任何一个，则不能进行连接。连接的接受可以由应用或系统管理例程触发。</p>
</li>
<li><p>数据传输</p>
<p>对于由机器A的TCP从ULP接收的每个数据块，TCP封装它并且以递增的序列号将其发送到机器B. 在机器B接收到消息之后，它使用增加下一个序列号的分段确认来确认它（并且因此指示它接收到该序列号的一切）。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/d/d7/Ntwk_data_trans.JPG" alt="tcp传输图" title="">
                </div>
                <div class="image-caption">tcp传输图</div>
            </figure>
<p>TCP数据传输服务实际上体现了六个不同的子服务：</p>
<ul>
<li><p>全双工：使连接的两端在任何时间，甚至同时发送。</p>
</li>
<li><p>及时性：使用计时器可确保在合理的时间内传输数据。</p>
</li>
<li><p>有序：从一个应用程序发送的数据将在另一端以相同的顺序接收。这发生，尽管事实上数据报可能通过IP被无序地接收，因为TCP在将消息传递到较高层之前以正确的顺序重新组装消息。</p>
</li>
<li><p>标签：所有连接具有商定的优先级和安全值。</p>
</li>
<li><p>受控流：TCP可以通过使用缓冲区和窗口限制来调节信息流。</p>
</li>
<li><p>错误校正：校验和确保数据没有错误（在校验和算法的限制内）。</p>
</li>
</ul>
</li>
<li><p>关闭连接<br>为了关闭连接，TCP之一从ULP接收关闭原语并发出具有设置为开的FIN标志的消息。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/c/c4/Ntwk_conn_close.JPG" alt="tcp关闭连接示意图" title="">
                </div>
                <div class="image-caption">tcp关闭连接示意图</div>
            </figure>
<p>在图中，机器A的TCP发送请求以关闭具有下一个序列号的机器B的连接。机器B然后将发送对该请求及其下一个序列号的确认。随后，机器B通过其ULP将关闭消息发送到应用程序，并等待应用程序确认关闭。这一步不是绝对必要的; TCP可以在没有应用程序批准的情况下关闭连接，但是一个良好的系统会通知应用程序状态的改变</p>
</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="什么是UDP"><a href="#什么是UDP" class="headerlink" title="什么是UDP"></a>什么是UDP</h3><p> UDP是无连接和不可靠的传输协议。两个端口用于标识源和目标机器内的端点。当不需要可靠的传递时，使用用户数据报协议来代替TCP。然而，UDP从不用于发送诸如网页，数据库信息等重要数据。流式媒体例如视频，音频和其他使用UDP因为它提供速度。</p>
<h3 id="UDP的特性"><a href="#UDP的特性" class="headerlink" title="UDP的特性"></a>UDP的特性</h3><ul>
<li><p>端到端。UDP可以识别在计算机上运行的特定进程。</p>
</li>
<li><p>不可靠，无连接传递（例如USPS:UDP使用无连接通信设置。在这个UDP中不需要在发送数据之前建立连接。通信仅由数据段本身组成）。</p>
</li>
<li><p>与IP相同的尽力语义</p>
</li>
<li><p>无ack，无序列，无流量控制</p>
</li>
<li><p>丢失，复制，延迟，无序或丢失连接</p>
</li>
<li><p>快速，低开销</p>
<p>因为以上特性udp更适合:</p>
<ul>
<li>适合可靠的本地网络</li>
<li>RTP（实时传输协议</li>
</ul>
</li>
</ul>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>UDP是传输层协议。UDP是一种无连接和不可靠的协议。UDP不做流量控制，错误控制或重传坏段。UDP比TCP快。UDP通常用于流音频和视频。UDP从未用于重要的文档，如网页，数据库信息等。UDP传输由8字节头组成的段。它包含源端口，目标端口，UDP长度和校验和。UDP校验和用于检测传输段中的“错误”。</p>
<h2 id="TCP-VS-UDP"><a href="#TCP-VS-UDP" class="headerlink" title="TCP VS UDP"></a>TCP VS UDP</h2><p> 用户数据报协议（UDP）和传输控制协议（TCP）是TCP / IP协议组中传输层的“同级”。它们执行相同的角色，提供应用程序和Internet协议（IP）的数据移动功能之间的接口，但是它们以非常不同的方式实现。因此，这两种协议为高层协议提供了选择，允许每个协议根据其需要选择适当的协议。</p>
<p> 有助于说明这两种协议的最重要的基本属性以及它们如何彼此对比的表：<br> <figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://upload.wikimedia.org/wikibooks/en/5/55/Tcp%26udp.jpg" alt="tcp&udp比较图" title="">
                </div>
                <div class="image-caption">tcp&udp比较图</div>
            </figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;TCP和UDP协议是IP网络中不同终端间通讯的两种传输协议。&lt;br&gt;在OSI模型中，TCP、UDP是传输层协议，其中TCP是面向连接的协议，
    
    </summary>
    
      <category term="网络协议" scheme="http://fudali.cc/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="网络" scheme="http://fudali.cc/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="tcp/ip" scheme="http://fudali.cc/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>排序-归并排序</title>
    <link href="http://fudali.cc/2017/03/17/merge-sort/"/>
    <id>http://fudali.cc/2017/03/17/merge-sort/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-18T05:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package merge</div><div class="line"></div><div class="line">func mergeSort(array []int) []int &#123;</div><div class="line">	middle := len(array) / 2</div><div class="line">	if middle == 1 &#123;</div><div class="line">		return array</div><div class="line">	&#125;</div><div class="line">	return merge(mergeSort(array[:middle]), mergeSort(array[middle:]))</div><div class="line">&#125;</div><div class="line"></div><div class="line">func merge(a1 []int, a2 []int) []int &#123;</div><div class="line">	a1Index := 0</div><div class="line">	a2Index := 0</div><div class="line">	resIndex := 0</div><div class="line">	resLen := len(a1) + len(a2)</div><div class="line">	res := make([]int, resLen)</div><div class="line">	for i := 0; i &lt; resLen; i++ &#123;</div><div class="line"></div><div class="line">		if a1Index == len(a1)-1 &#123;</div><div class="line">			for ; a2Index &lt; len(a2); a2Index++ &#123;</div><div class="line">				res[resIndex] = a2[a2Index]</div><div class="line">				resIndex++</div><div class="line">			&#125;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if a2Index == len(a1)-1 &#123;</div><div class="line">			for ; a1Index &lt; len(a1); a1Index++ &#123;</div><div class="line">				res[resIndex] = a1[a1Index]</div><div class="line">				resIndex++</div><div class="line">			&#125;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if a1[a1Index] &lt; a2[a2Index] &#123;</div><div class="line">			res[resIndex] = a1[a1Index]</div><div class="line">			a1Index++</div><div class="line">		&#125; else &#123;</div><div class="line">			res[resIndex] = a2[a2Index]</div><div class="line">			a2Index++</div><div class="line">		&#125;</div><div class="line">		resIndex++</div><div class="line">	&#125;</div><div class="line">	return res</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/merge/merge.go" target="_blank" rel="external">golang code in github</a><br>待改善</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div c
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序-希尔排序</title>
    <link href="http://fudali.cc/2017/03/15/shell-sort/"/>
    <id>http://fudali.cc/2017/03/15/shell-sort/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2017-03-18T04:53:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>个人认为希尔排序是对插入排序的一种优化，<br>他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序)。<br>所以希尔排序也称为缩减增量排序<br>他相比插入排序所在的优势是，他可以一次交换两个较远距离的元素，而插入排序交换两个相聚n的元素位子需要n次交换。</p>
<p>因为他根据一个算法来决定每趟比较的距离，所以该算法的好坏也会在一定程度上决定希尔排序的性能</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 利用每次除以2的等比增量数列来决定每趟比较距离</div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	arrayLen := len(array)</div><div class="line">	for gap := arrayLen / 2; gap &gt; 0; gap /= 2 &#123;</div><div class="line">		for i := gap; i &lt; arrayLen; i++ &#123;</div><div class="line">			iv := array[i]</div><div class="line">			for j := i; j-gap &gt; 0 &amp;&amp; array[j-gap] &gt; iv; j -= gap &#123;</div><div class="line">				n++</div><div class="line">				array[j-gap], array[j] = iv, array[j-gap]</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;---------------&quot;, n)</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/shell/shell.go" target="_blank" rel="external">golang code in github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;个人认为希尔排序是对插入排序的一种优化，&lt;br&gt;他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序-插入排序</title>
    <link href="http://fudali.cc/2017/03/13/insertion-sort/"/>
    <id>http://fudali.cc/2017/03/13/insertion-sort/</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2017-03-18T04:52:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  -<br>  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模式方面的知识<br>  -<br>  今天就想来理解一下排序算法中最简单的插入排序：<br>  插入排序思路为顺序遍历数组，并在遍历中从顺序遍历到的元素倒序遍历回<br>  倒序遍历是判断相邻两个元素是否符合排序规则<br>  如果符合则停止倒序遍历<br>  如果不符合则交换相邻两个元素位置并继续倒序遍历</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ppackage main</div><div class="line"></div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	// 从1开始遍历,因为0前面没有数值</div><div class="line">	for i := 1; i &lt; len(array); i++ &#123;</div><div class="line">		// 在此处放置与在 代码1 处放置效果一样</div><div class="line">		// 因为若 jv &gt; iv 的话 ， j 与 j-1 调换位置， 下一次循环时 array[j] 依然是当初的 iv</div><div class="line">		iv := array[i]</div><div class="line">		for j := i; j &gt;= 0 &amp;&amp; array[j-1] &gt;= iv; j-- &#123;</div><div class="line">			// 代码1  iv := array[j]</div><div class="line"></div><div class="line">			// 如果 jv &gt; iv , 调换两个元素之间的位置</div><div class="line">			n++</div><div class="line">			array[j], array[j-1] = array[j-1], iv</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;----------------&quot;, n)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/insertion.go" target="_blank" rel="external">golang code in github</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Insertion &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Integer[] oo = new Integer[]&#123;34, 8, 64, 51, 32, 21&#125;;</div><div class="line">	    sort(oo);</div><div class="line">        for (Integer var : oo) &#123;</div><div class="line">            System.out.println(var);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; void sort(T[] array) &#123;</div><div class="line">        for (int i = 1; i&lt; array.length; i++) &#123;</div><div class="line">            T it = array[i];</div><div class="line">            for (int j = i; j &gt; 0; j--) &#123;</div><div class="line">                T jt = array[j - 1];</div><div class="line">                if (compare(jt, it) &lt; 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;else &#123;</div><div class="line">                    array[j] = jt;</div><div class="line">                    array[j - 1] = it;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; int compare(T o1, T o2) &#123;</div><div class="line">        return (Integer)o1 - (Integer)o2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/Insertion.java" target="_blank" rel="external">java code in github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从原理和显示方式可以看出，当数组本就按排序规则排好序时，时间复杂度最小为 O(N)<br>当数组中根据排序规则倒序的元素对越多，时间复杂度越大，当数组根据排序规则完全倒序时，时间复杂度最大为 2+3+4+…+N = O(N)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  -&lt;br&gt;  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模
    
    </summary>
    
      <category term="算法" scheme="http://fudali.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>beego upsert 方法原理</title>
    <link href="http://fudali.cc/2016/12/13/beego-upsert-method/"/>
    <id>http://fudali.cc/2016/12/13/beego-upsert-method/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2017-03-18T04:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂只支持mysql与postgres。实现原理是数据自带可实现insertorupdate的功能语句。<br>mysql：<strong><code>ON DUPLICATE KEY UPDATE</code></strong><br>postgres : <strong><code>ON CONFLICT DO UPDATE SET</code></strong><br>然后去orm实现中自己拼装sql语句</li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><ul>
<li>好了，亮代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">func (d *dbBase) InsertOrUpdate(q dbQuerier, mi *modelInfo,ind reflect.Value, tz *time.Location, dn string, args ...string) (int64, error) &#123;</div><div class="line"></div><div class="line">	iouStr := &quot;&quot;</div><div class="line">	mysql := &quot;mysql&quot;</div><div class="line">	postgres := &quot;postgres&quot;</div><div class="line">	argsMap := map[string]string&#123;&#125;</div><div class="line"></div><div class="line">	if dn == mysql &#123;</div><div class="line">		iouStr = &quot;ON DUPLICATE KEY UPDATE&quot;</div><div class="line">	&#125; else if dn == postgres &amp;&amp; len(args) &gt; 0 &#123;</div><div class="line">		args0 = args[0]</div><div class="line">		iouStr = fmt.Sprintf(&quot;ON CONFLICT (%s) DO UPDATE SET&quot;, args0)</div><div class="line">	&#125; else &#123;</div><div class="line">		return 0, fmt.Errorf(&quot;`%s` nonsupport insert or update in beego&quot;, dn)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for _, v := range args &#123;</div><div class="line">		kv := strings.Split(v, &quot;=&quot;)</div><div class="line">		if len(kv) == 2 &#123;</div><div class="line">			argsMap[kv[0]] = kv[1]</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	isMulti := false</div><div class="line">	names := make([]string, 0, len(mi.fields.dbcols)-1)</div><div class="line">	Q := d.ins.TableQuote()</div><div class="line">	values, err := d.collectValues(mi, ind, mi.fields.dbcols, true, true, &amp;names, tz)</div><div class="line">	if err != nil &#123;</div><div class="line">		return 0, err</div><div class="line"></div><div class="line">	marks := make([]string, len(names))</div><div class="line">	updateValues := make([]interface&#123;&#125;, 0)</div><div class="line">	updates := make([]string, len(names))</div><div class="line">	var conflitValue interface&#123;&#125;</div><div class="line">	for i, v := range names &#123;</div><div class="line">		marks[i] = &quot;?&quot;</div><div class="line">		valueStr := argsMap[v]</div><div class="line">		if v == args0 &#123;</div><div class="line">			conflitValue = values[i]</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if valueStr != &quot;&quot; &#123;</div><div class="line">			switch dn &#123;</div><div class="line">			case mysql:</div><div class="line">				updates[i] = v + &quot;=&quot; + valueStr</div><div class="line">				break</div><div class="line">			case postgres:</div><div class="line">				if conflitValue != nil &#123;</div><div class="line">			updates[i] = fmt.Sprintf(&quot;%s=(select %s from %s where %s = ? )&quot;, v, valueStr, mi.table, args[0])</div><div class="line">					updateValues = append(updateValues, conflitValue)</div><div class="line">				&#125; else &#123;</div><div class="line">					return 0, fmt.Errorf(&quot;`%s` must be in front of `%s` in your struct&quot;, args[0], v)</div><div class="line">				&#125;</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			updates[i] = v + &quot;=?&quot;</div><div class="line">			updateValues = append(updateValues, values[i])</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	values = append(values, updateValues...)</div><div class="line">	sep := fmt.Sprintf(&quot;%s, %s&quot;, Q, Q)</div><div class="line">	qmarks := strings.Join(marks, &quot;, &quot;)</div><div class="line">	qupdates := strings.Join(updates, &quot;, &quot;)</div><div class="line">	columns := strings.Join(names, sep)</div><div class="line">	multi := len(values) / len(names)</div><div class="line"></div><div class="line">	if isMulti &#123;</div><div class="line">		qmarks = strings.Repeat(qmarks+&quot;), (&quot;, multi-1) + qmarks</div><div class="line">	&#125;</div><div class="line">	query := fmt.Sprintf(&quot;INSERT INTO %s%s%s (%s%s%s) VALUES (%s) %s &quot;+qupdates, Q, mi.table, Q, Q, columns, Q, qmarks, iouStr)</div><div class="line"></div><div class="line">	if isMulti || !d.ins.HasReturningID(mi, &amp;query) &#123;</div><div class="line">		res, err := q.Exec(query, values...)</div><div class="line">		if err == nil &#123;</div><div class="line">			if isMulti &#123;</div><div class="line">				return res.RowsAffected()</div><div class="line">			&#125;</div><div class="line">			return res.LastInsertId()</div><div class="line">		&#125;</div><div class="line">		return 0, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	row := q.QueryRow(query, values...)</div><div class="line">	var id int64</div><div class="line">	err = row.Scan(&amp;id)</div><div class="line">	return id, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>这就是实现功能的全部逻辑，当然要想在beego orm中使用insertorupdate还有一些其他的工作要做，首先这段代码应该添加在 <strong><code>beego/orm文件夹下的db.go文件中</code></strong></p>
</li>
<li><p>然后在 <strong><code>orm.go</code></strong> 文件中添加</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> func (o *orm) InsertOrUpdate(md interface&#123;&#125;,colConflitAndArgs ...string) (int64, error) &#123;</div><div class="line"></div><div class="line">	mi, ind := o.getMiInd(md, true)</div><div class="line">	id, err := o.alias.DbBaser.InsertOrUpdate(o.db, mi, ind, o.alias.TZ, o.alias.DriverName, colConflitAndArgs...)</div><div class="line">	if err != nil &#123;</div><div class="line">		return id, err</div><div class="line">		&#125;</div><div class="line">	o.setPk(mi, ind, id)</div><div class="line">	return id, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">再在types.go文件中的type Ormer interface和type dbBaser interface中分别添加</div><div class="line">InsertOrUpdate(md interface&#123;&#125;, colConflitAndArgs ...string) (int64, error) 与</div><div class="line">InsertOrUpdate(dbQuerier, *modelInfo, reflect.Value, *time.Location, string, ...string) (int64, error)</div></pre></td></tr></table></figure>
<ul>
<li>好了，现在大功告成了。可以使用InssertOrUpdate功能了<br>列如：</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql：</div><div class="line"></div><div class="line">func IOUFinish(all *Finish) int64 &#123;</div><div class="line"></div><div class="line">	db := orm.NewOrm()</div><div class="line">	db.Using(&quot;mysql&quot;)</div><div class="line">	r, e := db.InsertOrUpdate(all, &quot;step=step+1&quot;)</div><div class="line">	if e != nil &#123;</div><div class="line">		fmt.Println(e)</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	fmt.Println(r)</div><div class="line">	return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个函数在出入数据时有主键或者唯一键冲突，将执行update操作，其中step列执行+自增操作，其他列按model中的值进行update操作。其中”step=step+1”格式数据可以有多个也可以没有，这种格式只用于自增操作</li>
</ul>
<h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">postgres：</div><div class="line"></div><div class="line">func IOUFinish(all *Finish) int64 &#123;</div><div class="line"></div><div class="line">	db := orm.NewOrm()</div><div class="line">	db.Using(&quot;postgres&quot;)</div><div class="line">	r, e := db.InsertOrUpdate(all,&quot;confilctColumnName&quot; &quot;step=step+1&quot;)</div><div class="line">	if e != nil &#123;</div><div class="line">		fmt.Println(e)</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	fmt.Println(r)</div><div class="line">	return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当操作postgres数据库是，必须在model后的第一个参数指定你预期的冲突列的列名(由于实现此功能的sql语句需要且数据库版本必须大于9.5，因为实现的语句由9.5版本推出)，其他与mysql一致。</li>
</ul>
<p>提示：在使用自增操作是最好不要自增主键或者唯一键，可能会引起错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂
    
    </summary>
    
      <category term="开源项目" scheme="http://fudali.cc/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="beego" scheme="http://fudali.cc/tags/beego/"/>
    
  </entry>
  
  <entry>
    <title>go 1.6.2 strings split 方法改造</title>
    <link href="http://fudali.cc/2016/12/13/go1.6.2-strings-split/"/>
    <id>http://fudali.cc/2016/12/13/go1.6.2-strings-split/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2017-03-18T04:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>当调用<code>strings.Split(s,seq string)</code>时,如果seq连续出现，比如<code>s=&quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk      &quot;</code>。调用<code>slice:=strings.Split(s,&quot; &quot;)</code>将会出现<code>len(slice)!=3</code>，我认为这并不是大家希望看到的结果。</p>
<p>查看<code>strings.Split(s,seq string)</code>源码：<br><code>func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }</code></p>
<p>接着查看<code>strings.genSplit()</code>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func genSplit(s, sep string, sepSave, n int) []string &#123;</div><div class="line">	if n == 0 &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	if sep == &quot;&quot; &#123;</div><div class="line">		return explode(s, n)</div><div class="line">	&#125;</div><div class="line">	if n &lt; 0 &#123;</div><div class="line">		n = Count(s, sep) + 1</div><div class="line">	&#125;</div><div class="line">	c := sep[0]</div><div class="line">	start := 0</div><div class="line">	a := make([]string, n)</div><div class="line">	na := 0</div><div class="line">	for i := 0; i+len(sep) &lt;= len(s) &amp;&amp; na+1 &lt; n; i++ &#123;</div><div class="line">		if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			a[na] = s[start : i+sepSave]</div><div class="line">			na++</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	a[na] = s[start:]</div><div class="line">	return a[0 : na+1]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发现并没有做相关的判断就将<code>s[start : i+sepSave]</code>添加到返回数组造成出现这种情况；</p>
<p>顾在for循环中添加一个判断以达到预期返回值，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			splitStr:=s[start : i+sepSave]</div><div class="line">			if !(splitStr == sep || start==i+sepSave) &#123;</div><div class="line">				a[na] = splitStr</div><div class="line">				na++</div><div class="line">			&#125;</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后调用即可达到预期返回值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当调用&lt;code&gt;strings.Split(s,seq string)&lt;/code&gt;时,如果seq连续出现，比如&lt;code&gt;s=&amp;quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk    
    
    </summary>
    
      <category term="golang笔记" scheme="http://fudali.cc/categories/golang%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>ELK学习之安装logstash</title>
    <link href="http://fudali.cc/2016/02/16/ELK-install-logstash/"/>
    <id>http://fudali.cc/2016/02/16/ELK-install-logstash/</id>
    <published>2016-02-15T16:00:00.000Z</published>
    <updated>2017-03-18T05:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ul>
<li>logstash基于jvm平台，所以安装前确认已安装jre</li>
<li>最新的logstash 5.*版本至少需要java8以上jre</li>
<li>对于Debian平台或者Redhat平台,官方推荐配置软件仓库并安装</li>
</ul>
<h3 id="Debian-Ubuntu-平台"><a href="#Debian-Ubuntu-平台" class="headerlink" title="Debian/Ubuntu 平台"></a>Debian/Ubuntu 平台</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | apt-key add -</div><div class="line">cat &gt;&gt; /etc/apt/sources.list &lt;&lt;EOF</div><div class="line">deb http://packages.elasticsearch.org/logstash/5.0/debian stable main</div><div class="line">EOF</div><div class="line">apt-get update</div><div class="line">apt-get install logstash</div></pre></td></tr></table></figure>
<p>一行一行复制输入命令行即可</p>
<p>有可能出现如下错误(也有可能是运行时出现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Could not find any executable java binary. Please install java in your PATH or set JAVA_HOME.</div></pre></td></tr></table></figure></p>
<p>此时需要修改logstash的启动配置文件，对Debian/Ubuntu系统，该文件路径为<code>/etc/logstash/startup.options</code>，其中的JAVACMD参数默认为<code>/usr/**</code>,顾导致找不到java命令，只需将改参数改为你的<code>$JAVA_HOME/bin/java</code>即可解决该错误</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>软件仓库安装后logstash bin所在路径为<code>/usr/share/logstash</code></p>
<p>直接运行简单命令行输入input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -e &apos;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>配置文件运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -f &#123;配置文件路径&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;logstash基于jvm平台，所以安装前确认已安装jre&lt;/li&gt;
&lt;li&gt;最新的logstash 5.*版本
    
    </summary>
    
      <category term="日志收集" scheme="http://fudali.cc/categories/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="ELK" scheme="http://fudali.cc/tags/ELK/"/>
    
      <category term="logstash" scheme="http://fudali.cc/tags/logstash/"/>
    
  </entry>
  
</feed>
