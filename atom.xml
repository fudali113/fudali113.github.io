<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fudali</title>
  <subtitle>do one`s best</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fudali.cc/"/>
  <updated>2017-03-17T09:38:34.000Z</updated>
  <id>http://fudali.cc/</id>
  
  <author>
    <name>fudali</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序-希尔排序</title>
    <link href="http://fudali.cc/2017/03/15/shell-sort/"/>
    <id>http://fudali.cc/2017/03/15/shell-sort/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2017-03-17T09:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>个人认为希尔排序是对插入排序的一种优化，<br>他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序)。<br>所以希尔排序也称为缩减增量排序<br>他相比插入排序所在的优势是，他可以一次交换两个较远距离的元素，而插入排序交换两个相聚n的元素位子需要n次交换。</p>
<p>因为他根据一个算法来决定每趟比较的距离，所以该算法的好坏也会在一定程度上决定希尔排序的性能</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 利用每次除以2的等比增量数列来决定每趟比较距离</div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	arrayLen := len(array)</div><div class="line">	for gap := arrayLen / 2; gap &gt; 0; gap /= 2 &#123;</div><div class="line">		for i := gap; i &lt; arrayLen; i++ &#123;</div><div class="line">			iv := array[i]</div><div class="line">			for j := i; j-gap &gt; 0 &amp;&amp; array[j-gap] &gt; iv; j -= gap &#123;</div><div class="line">				n++</div><div class="line">				array[j-gap], array[j] = iv, array[j-gap]</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;---------------&quot;, n)</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/shell/shell.go" target="_blank" rel="external">golang code in github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;个人认为希尔排序是对插入排序的一种优化，&lt;br&gt;他利用一定的算法来决定每趟遍历比较两个元素之前的距离，最后的比较距离为1(此时等同于插入排序
    
    </summary>
    
      <category term="前言" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80/"/>
    
      <category term="代码实现 - go" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-go/"/>
    
      <category term="总结" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-go/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序-插入排序</title>
    <link href="http://fudali.cc/2017/03/13/insertion-sort/"/>
    <id>http://fudali.cc/2017/03/13/insertion-sort/</id>
    <published>2017-03-12T16:00:00.000Z</published>
    <updated>2017-03-17T09:36:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  -<br>  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模式方面的知识<br>  -<br>  今天就想来理解一下排序算法中最简单的插入排序：<br>  插入排序思路为顺序遍历数组，并在遍历中从顺序遍历到的元素倒序遍历回<br>  倒序遍历是判断相邻两个元素是否符合排序规则<br>  如果符合则停止倒序遍历<br>  如果不符合则交换相邻两个元素位置并继续倒序遍历</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ppackage main</div><div class="line"></div><div class="line">func sort(array []int) &#123;</div><div class="line">	n := 0</div><div class="line">	// 从1开始遍历,因为0前面没有数值</div><div class="line">	for i := 1; i &lt; len(array); i++ &#123;</div><div class="line">		// 在此处放置与在 代码1 处放置效果一样</div><div class="line">		// 因为若 jv &gt; iv 的话 ， j 与 j-1 调换位置， 下一次循环时 array[j] 依然是当初的 iv</div><div class="line">		iv := array[i]</div><div class="line">		for j := i; j &gt;= 0 &amp;&amp; array[j-1] &gt;= iv; j-- &#123;</div><div class="line">			// 代码1  iv := array[j]</div><div class="line"></div><div class="line">			// 如果 jv &gt; iv , 调换两个元素之间的位置</div><div class="line">			n++</div><div class="line">			array[j], array[j-1] = array[j-1], iv</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;----------------&quot;, n)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	array := []int&#123;10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45&#125;</div><div class="line">	sort(array)</div><div class="line">	for _, v := range array &#123;</div><div class="line">		println(v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/insertion.go" target="_blank" rel="external">golang code in github</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Insertion &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Integer[] oo = new Integer[]&#123;34, 8, 64, 51, 32, 21&#125;;</div><div class="line">	    sort(oo);</div><div class="line">        for (Integer var : oo) &#123;</div><div class="line">            System.out.println(var);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; void sort(T[] array) &#123;</div><div class="line">        for (int i = 1; i&lt; array.length; i++) &#123;</div><div class="line">            T it = array[i];</div><div class="line">            for (int j = i; j &gt; 0; j--) &#123;</div><div class="line">                T jt = array[j - 1];</div><div class="line">                if (compare(jt, it) &lt; 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;else &#123;</div><div class="line">                    array[j] = jt;</div><div class="line">                    array[j - 1] = it;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static &lt;T&gt; int compare(T o1, T o2) &#123;</div><div class="line">        return (Integer)o1 - (Integer)o2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/fudali113/learn-basic/blob/master/sort/insertion/Insertion.java" target="_blank" rel="external">java code in github</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从原理和显示方式可以看出，当数组本就按排序规则排好序时，时间复杂度最小为 O(N)<br>当数组中根据排序规则倒序的元素对越多，时间复杂度越大，当数组根据排序规则完全倒序时，时间复杂度最大为 2+3+4+…+N = O(N)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  -&lt;br&gt;  今天感觉受到了一些打击，感觉自己基础知识过于缺乏，顾决定从今日起，有空就写一篇博客，加强自己在算法与数据结构、网络、设计模
    
    </summary>
    
      <category term="前言 - 1 - 2" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80-1-2/"/>
    
      <category term="代码实现 - go - java" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80-1-2/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-go-java/"/>
    
      <category term="总结" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80-1-2/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-go-java/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="排序" scheme="http://fudali.cc/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="学习" scheme="http://fudali.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>beego upsert 方法原理</title>
    <link href="http://fudali.cc/2016/12/13/beego-upsert-method/"/>
    <id>http://fudali.cc/2016/12/13/beego-upsert-method/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2017-03-17T09:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂只支持mysql与postgres。实现原理是数据自带可实现insertorupdate的功能语句。<br>mysql：<strong><code>ON DUPLICATE KEY UPDATE</code></strong><br>postgres : <strong><code>ON CONFLICT DO UPDATE SET</code></strong><br>然后去orm实现中自己拼装sql语句</li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><ul>
<li>好了，亮代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">func (d *dbBase) InsertOrUpdate(q dbQuerier, mi *modelInfo,ind reflect.Value, tz *time.Location, dn string, args ...string) (int64, error) &#123;</div><div class="line"></div><div class="line">	iouStr := &quot;&quot;</div><div class="line">	mysql := &quot;mysql&quot;</div><div class="line">	postgres := &quot;postgres&quot;</div><div class="line">	argsMap := map[string]string&#123;&#125;</div><div class="line"></div><div class="line">	if dn == mysql &#123;</div><div class="line">		iouStr = &quot;ON DUPLICATE KEY UPDATE&quot;</div><div class="line">	&#125; else if dn == postgres &amp;&amp; len(args) &gt; 0 &#123;</div><div class="line">		args0 = args[0]</div><div class="line">		iouStr = fmt.Sprintf(&quot;ON CONFLICT (%s) DO UPDATE SET&quot;, args0)</div><div class="line">	&#125; else &#123;</div><div class="line">		return 0, fmt.Errorf(&quot;`%s` nonsupport insert or update in beego&quot;, dn)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for _, v := range args &#123;</div><div class="line">		kv := strings.Split(v, &quot;=&quot;)</div><div class="line">		if len(kv) == 2 &#123;</div><div class="line">			argsMap[kv[0]] = kv[1]</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	isMulti := false</div><div class="line">	names := make([]string, 0, len(mi.fields.dbcols)-1)</div><div class="line">	Q := d.ins.TableQuote()</div><div class="line">	values, err := d.collectValues(mi, ind, mi.fields.dbcols, true, true, &amp;names, tz)</div><div class="line">	if err != nil &#123;</div><div class="line">		return 0, err</div><div class="line"></div><div class="line">	marks := make([]string, len(names))</div><div class="line">	updateValues := make([]interface&#123;&#125;, 0)</div><div class="line">	updates := make([]string, len(names))</div><div class="line">	var conflitValue interface&#123;&#125;</div><div class="line">	for i, v := range names &#123;</div><div class="line">		marks[i] = &quot;?&quot;</div><div class="line">		valueStr := argsMap[v]</div><div class="line">		if v == args0 &#123;</div><div class="line">			conflitValue = values[i]</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if valueStr != &quot;&quot; &#123;</div><div class="line">			switch dn &#123;</div><div class="line">			case mysql:</div><div class="line">				updates[i] = v + &quot;=&quot; + valueStr</div><div class="line">				break</div><div class="line">			case postgres:</div><div class="line">				if conflitValue != nil &#123;</div><div class="line">			updates[i] = fmt.Sprintf(&quot;%s=(select %s from %s where %s = ? )&quot;, v, valueStr, mi.table, args[0])</div><div class="line">					updateValues = append(updateValues, conflitValue)</div><div class="line">				&#125; else &#123;</div><div class="line">					return 0, fmt.Errorf(&quot;`%s` must be in front of `%s` in your struct&quot;, args[0], v)</div><div class="line">				&#125;</div><div class="line">				break</div><div class="line">			&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			updates[i] = v + &quot;=?&quot;</div><div class="line">			updateValues = append(updateValues, values[i])</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	values = append(values, updateValues...)</div><div class="line">	sep := fmt.Sprintf(&quot;%s, %s&quot;, Q, Q)</div><div class="line">	qmarks := strings.Join(marks, &quot;, &quot;)</div><div class="line">	qupdates := strings.Join(updates, &quot;, &quot;)</div><div class="line">	columns := strings.Join(names, sep)</div><div class="line">	multi := len(values) / len(names)</div><div class="line"></div><div class="line">	if isMulti &#123;</div><div class="line">		qmarks = strings.Repeat(qmarks+&quot;), (&quot;, multi-1) + qmarks</div><div class="line">	&#125;</div><div class="line">	query := fmt.Sprintf(&quot;INSERT INTO %s%s%s (%s%s%s) VALUES (%s) %s &quot;+qupdates, Q, mi.table, Q, Q, columns, Q, qmarks, iouStr)</div><div class="line"></div><div class="line">	if isMulti || !d.ins.HasReturningID(mi, &amp;query) &#123;</div><div class="line">		res, err := q.Exec(query, values...)</div><div class="line">		if err == nil &#123;</div><div class="line">			if isMulti &#123;</div><div class="line">				return res.RowsAffected()</div><div class="line">			&#125;</div><div class="line">			return res.LastInsertId()</div><div class="line">		&#125;</div><div class="line">		return 0, err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	row := q.QueryRow(query, values...)</div><div class="line">	var id int64</div><div class="line">	err = row.Scan(&amp;id)</div><div class="line">	return id, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>这就是实现功能的全部逻辑，当然要想在beego orm中使用insertorupdate还有一些其他的工作要做，首先这段代码应该添加在 <strong><code>beego/orm文件夹下的db.go文件中</code></strong></p>
</li>
<li><p>然后在 <strong><code>orm.go</code></strong> 文件中添加</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> func (o *orm) InsertOrUpdate(md interface&#123;&#125;,colConflitAndArgs ...string) (int64, error) &#123;</div><div class="line"></div><div class="line">	mi, ind := o.getMiInd(md, true)</div><div class="line">	id, err := o.alias.DbBaser.InsertOrUpdate(o.db, mi, ind, o.alias.TZ, o.alias.DriverName, colConflitAndArgs...)</div><div class="line">	if err != nil &#123;</div><div class="line">		return id, err</div><div class="line">		&#125;</div><div class="line">	o.setPk(mi, ind, id)</div><div class="line">	return id, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">再在types.go文件中的type Ormer interface和type dbBaser interface中分别添加</div><div class="line">InsertOrUpdate(md interface&#123;&#125;, colConflitAndArgs ...string) (int64, error) 与</div><div class="line">InsertOrUpdate(dbQuerier, *modelInfo, reflect.Value, *time.Location, string, ...string) (int64, error)</div></pre></td></tr></table></figure>
<ul>
<li>好了，现在大功告成了。可以使用InssertOrUpdate功能了<br>列如：</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql：</div><div class="line"></div><div class="line">func IOUFinish(all *Finish) int64 &#123;</div><div class="line"></div><div class="line">	db := orm.NewOrm()</div><div class="line">	db.Using(&quot;mysql&quot;)</div><div class="line">	r, e := db.InsertOrUpdate(all, &quot;step=step+1&quot;)</div><div class="line">	if e != nil &#123;</div><div class="line">		fmt.Println(e)</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	fmt.Println(r)</div><div class="line">	return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个函数在出入数据时有主键或者唯一键冲突，将执行update操作，其中step列执行+自增操作，其他列按model中的值进行update操作。其中”step=step+1”格式数据可以有多个也可以没有，这种格式只用于自增操作</li>
</ul>
<h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">postgres：</div><div class="line"></div><div class="line">func IOUFinish(all *Finish) int64 &#123;</div><div class="line"></div><div class="line">	db := orm.NewOrm()</div><div class="line">	db.Using(&quot;postgres&quot;)</div><div class="line">	r, e := db.InsertOrUpdate(all,&quot;confilctColumnName&quot; &quot;step=step+1&quot;)</div><div class="line">	if e != nil &#123;</div><div class="line">		fmt.Println(e)</div><div class="line">		return 0</div><div class="line">	&#125;</div><div class="line">	fmt.Println(r)</div><div class="line">	return r</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当操作postgres数据库是，必须在model后的第一个参数指定你预期的冲突列的列名(由于实现此功能的sql语句需要且数据库版本必须大于9.5，因为实现的语句由9.5版本推出)，其他与mysql一致。</li>
</ul>
<p>提示：在使用自增操作是最好不要自增主键或者唯一键，可能会引起错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在beego1.6.1版本orm中并未提供insertOrUpdate，但是自己做项目时遇到了这个需求，顾写了一个自己的实现，暂
    
    </summary>
    
      <category term="前言" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80/"/>
    
      <category term="code - mysql - postgresql" scheme="http://fudali.cc/categories/%E5%89%8D%E8%A8%80/code-mysql-postgresql/"/>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
      <category term="beego" scheme="http://fudali.cc/tags/beego/"/>
    
  </entry>
  
  <entry>
    <title>go 1.6.2 strings split 方法改造</title>
    <link href="http://fudali.cc/2016/12/13/go1.6.2-strings-split/"/>
    <id>http://fudali.cc/2016/12/13/go1.6.2-strings-split/</id>
    <published>2016-12-12T16:00:00.000Z</published>
    <updated>2017-03-17T09:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>当调用<code>strings.Split(s,seq string)</code>时,如果seq连续出现，比如<code>s=&quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk      &quot;</code>。调用<code>slice:=strings.Split(s,&quot; &quot;)</code>将会出现<code>len(slice)!=3</code>，我认为这并不是大家希望看到的结果。</p>
<p>查看<code>strings.Split(s,seq string)</code>源码：<br><code>func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }</code></p>
<p>接着查看<code>strings.genSplit()</code>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func genSplit(s, sep string, sepSave, n int) []string &#123;</div><div class="line">	if n == 0 &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	if sep == &quot;&quot; &#123;</div><div class="line">		return explode(s, n)</div><div class="line">	&#125;</div><div class="line">	if n &lt; 0 &#123;</div><div class="line">		n = Count(s, sep) + 1</div><div class="line">	&#125;</div><div class="line">	c := sep[0]</div><div class="line">	start := 0</div><div class="line">	a := make([]string, n)</div><div class="line">	na := 0</div><div class="line">	for i := 0; i+len(sep) &lt;= len(s) &amp;&amp; na+1 &lt; n; i++ &#123;</div><div class="line">		if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			a[na] = s[start : i+sepSave]</div><div class="line">			na++</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	a[na] = s[start:]</div><div class="line">	return a[0 : na+1]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发现并没有做相关的判断就将<code>s[start : i+sepSave]</code>添加到返回数组造成出现这种情况；</p>
<p>顾在for循环中添加一个判断以达到预期返回值，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if s[i] == c &amp;&amp; (len(sep) == 1 || s[i:i+len(sep)] == sep) &#123;</div><div class="line">			splitStr:=s[start : i+sepSave]</div><div class="line">			if !(splitStr == sep || start==i+sepSave) &#123;</div><div class="line">				a[na] = splitStr</div><div class="line">				na++</div><div class="line">			&#125;</div><div class="line">			start = i + len(sep)</div><div class="line">			i += len(sep) - 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后调用即可达到预期返回值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当调用&lt;code&gt;strings.Split(s,seq string)&lt;/code&gt;时,如果seq连续出现，比如&lt;code&gt;s=&amp;quot; dfdgdfg              （多个空格）        dfdg   （多个空格）   hghyjkjuyk    
    
    </summary>
    
    
      <category term="golang" scheme="http://fudali.cc/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>ELK学习之安装logstash</title>
    <link href="http://fudali.cc/2016/02/16/ELK_install_logstash/"/>
    <id>http://fudali.cc/2016/02/16/ELK_install_logstash/</id>
    <published>2016-02-15T16:00:00.000Z</published>
    <updated>2017-02-17T12:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><ul>
<li>logstash基于jvm平台，所以安装前确认已安装jre</li>
<li>最新的logstash 5.*版本至少需要java8以上jre</li>
<li>对于Debian平台或者Redhat平台,官方推荐配置软件仓库并安装</li>
</ul>
<h3 id="Debian-Ubuntu-平台"><a href="#Debian-Ubuntu-平台" class="headerlink" title="Debian/Ubuntu 平台"></a>Debian/Ubuntu 平台</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget -O - http://packages.elasticsearch.org/GPG-KEY-elasticsearch | apt-key add -</div><div class="line">cat &gt;&gt; /etc/apt/sources.list &lt;&lt;EOF</div><div class="line">deb http://packages.elasticsearch.org/logstash/5.0/debian stable main</div><div class="line">EOF</div><div class="line">apt-get update</div><div class="line">apt-get install logstash</div></pre></td></tr></table></figure>
<p>一行一行复制输入命令行即可</p>
<p>有可能出现如下错误(也有可能是运行时出现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Could not find any executable java binary. Please install java in your PATH or set JAVA_HOME.</div></pre></td></tr></table></figure></p>
<p>此时需要修改logstash的启动配置文件，对Debian/Ubuntu系统，该文件路径为<code>/etc/logstash/startup.options</code>，其中的JAVACMD参数默认为<code>/usr/**</code>,顾导致找不到java命令，只需将改参数改为你的<code>$JAVA_HOME/bin/java</code>即可解决该错误</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>软件仓库安装后logstash bin所在路径为<code>/usr/share/logstash</code></p>
<p>直接运行简单命令行输入input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -e &apos;input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>配置文件运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -f &#123;配置文件路径&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;logstash基于jvm平台，所以安装前确认已安装jre&lt;/li&gt;
&lt;li&gt;最新的logstash 5.*版本
    
    </summary>
    
      <category term="下载安装" scheme="http://fudali.cc/categories/%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"/>
    
      <category term="运行" scheme="http://fudali.cc/categories/%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/%E8%BF%90%E8%A1%8C/"/>
    
    
      <category term="ELK" scheme="http://fudali.cc/tags/ELK/"/>
    
      <category term="logstash" scheme="http://fudali.cc/tags/logstash/"/>
    
  </entry>
  
</feed>
